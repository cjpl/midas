C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MSCBMAIN
OBJECT MODULE PLACED IN .\mscbmain.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\src\mscbmain.c OPTIMIZE(4,SPEED) BROWSE INCDIR(\midas\mscb\embedded\incl
                    -ude) DEBUG OBJECTEXTEND PRINT(.\mscbmain.lst) TABS(3) OBJECT(.\mscbmain.obj)

line level    source

   1          /********************************************************************\
   2          
   3            Name:         mscbmain.c
   4            Created by:   Stefan Ritt
   5          
   6            Contents:     Midas Slow Control Bus protocol main program
   7          
   8            $Id$
   9          
  10          \********************************************************************/
  11          
  12          #include <stdio.h>
  13          #include <string.h>
  14          #include <intrins.h>
  15          #include <stdlib.h>
  16          #include "mscbemb.h"
  17          
  18          #ifdef CFG_HAVE_LCD
              #include "lcd.h"
              #endif
  21          
  22          /* GET_INFO attributes */
  23          #define GET_INFO_GENERAL  0
  24          #define GET_INFO_VARIABLE 1
  25          
  26          /* Variable attributes */
  27          #define SIZE_8BIT         1
  28          #define SIZE_16BIT        2
  29          #define SIZE_24BIT        3
  30          #define SIZE_32BIT        4
  31          
  32          /* Address modes */
  33          #define ADDR_NONE         0
  34          #define ADDR_NODE         1
  35          #define ADDR_GROUP        2
  36          #define ADDR_ALL          3
  37          
  38          /*---- functions and data in user part -----------------------------*/
  39          
  40          void user_init(unsigned char init);
  41          void user_write(unsigned char index) reentrant;
  42          unsigned char user_read(unsigned char index);
  43          void user_loop(void);
  44          
  45          extern MSCB_INFO_VAR *variables;
  46          extern unsigned char idata _n_sub_addr;
  47          
  48          extern char code node_name[];
  49          
  50          char code svn_rev_main[] = "$Rev$";
  51          
  52          /*------------------------------------------------------------------*/
  53          
  54          /* funtions in mscbutil.c */
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 2   

  55          
  56          #ifdef CFG_HAVE_LCD
              extern bit lcd_present;
              #endif
  59          
  60          #ifdef CFG_UART1_DEVICE
  61          extern void rs232_output(void);
  62          #endif
  63          
  64          /* forward declarations */
  65          void flash_upgrade(void);
  66          void send_remote_var(unsigned char i);
  67          
  68          /*------------------------------------------------------------------*/
  69          
  70          /* variables in internal RAM (indirect addressing) */
  71          
  72          #if defined(CPU_C8051F020) || defined(CPU_C8051F120)
  73          unsigned char xdata in_buf[256], out_buf[64];
  74          #else
              unsigned char idata in_buf[20], out_buf[8];
              #endif
  77          
  78          unsigned char idata i_in, last_i_in, final_i_in, i_out, cmd_len;
  79          unsigned char idata crc_code, addr_mode, n_variables;
  80          
  81          /* use absolute value between main program and upgrader */
  82          unsigned char idata _flkey _at_ 0x80;
  83          unsigned char idata n_out _at_ 0x81;
  84          
  85          unsigned char idata _cur_sub_addr, _var_size;
  86          
  87          #ifdef CFG_UART1_MSCB
              unsigned char idata var_to_send = 0xFF;
              #endif
  90          
  91          SYS_INFO idata sys_info;
  92          
  93          #ifdef CFG_HAVE_RTC
              /* buffer for setting RTC */
              unsigned char xdata rtc_bread[6];
              unsigned char xdata rtc_bwrite[6];
              bit rtc_set;
              #endif
  99          
 100          /*------------------------------------------------------------------*/
 101          
 102          /* bit variables in internal RAM */
 103          
 104          sbit RS485_ENABLE = RS485_EN_PIN; // port pin for RS485 enable
 105          
 106          #ifdef EXT_WATCHDOG_PIN
              sbit EXT_WATCHDOG = EXT_WATCHDOG_PIN; // port pin for external watchdog
              #endif
 109          
 110          unsigned char bdata CSR;        // byte address of CSR consisting of bits below 
 111          
 112          sbit DEBUG_MODE = CSR ^ 0;      // debugging mode
 113          sbit SYNC_MODE = CSR ^ 1;       // turned on in SYNC mode
 114          sbit FREEZE_MODE = CSR ^ 2;     // turned on in FREEZE mode
 115          sbit WD_RESET = CSR ^ 3;        // got rebooted by watchdog reset
 116          
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 3   

 117          bit addressed;                  // true if node addressed
 118          bit flash_param;                // used for EEPROM flashing
 119          bit flash_program;              // used for upgrading firmware
 120          bit configured_addr;            // TRUE if node address is configured
 121          bit configured_vars;            // TRUE if variables are configured
 122          bit flash_allowed;              // TRUE 5 sec after booting node
 123          bit wrong_cpu;                  // TRUE if code uses xdata and CPU does't have it
 124          
 125          /*------------------------------------------------------------------*/
 126          
 127          void setup(void)
 128          {
 129   1         unsigned char adr, flags, d;
 130   1         unsigned short i;
 131   1         unsigned char *p;
 132   1      
 133   1         _flkey = 0;
 134   1         
 135   1         /* first disable watchdog */
 136   1         watchdog_disable();
 137   1      
 138   1         /* avoid any blocking of RS485 bus */
 139   1         RS485_ENABLE = RS485_ENABLE_OFF;
 140   1      
 141   1         /* Port and oscillator configuration */
 142   1      
 143   1      #if defined(CPU_C8051F120)
 144   1      
 145   1         SFRPAGE   = CONFIG_PAGE;
 146   1        
 147   1         XBR0 = 0x04;                 // Enable XBar, UART0 & UART1
 148   1         XBR1 = 0x00;
 149   1         XBR2 = 0x44;
 150   1      
 151   1        #ifdef CLK_25MHZ
 152   1         /* Select internal quartz oscillator */
 153   1         SFRPAGE   = LEGACY_PAGE;
 154   1         FLSCL     = 0x00;            // set flash read time for <25 MHz
 155   1      
 156   1         SFRPAGE   = CONFIG_PAGE;
 157   1         OSCICN    = 0x83;            // divide by 1
 158   1         CLKSEL    = 0x00;            // select internal oscillator
 159   1        #else          // 98 MHz
                 /* Select internal quartz oscillator */
                 SFRPAGE   = LEGACY_PAGE;
                 FLSCL     = 0xB0;            // set flash read time for 100 MHz
              
                 SFRPAGE   = CONFIG_PAGE;
                 OSCICN    = 0x83;            // divide by 1
                 CLKSEL    = 0x00;            // select internal oscillator
              
                 PLL0CN    |= 0x01;
                 PLL0DIV   = 0x01;
                 PLL0FLT   = 0x01;
                 PLL0MUL   = 0x04;
                 for (i = 0 ; i < 15; i++);   // Wait 5us for initialization
                 PLL0CN    |= 0x02;
                 for (i = 0 ; i<50000 && ((PLL0CN & 0x10) == 0) ; i++);
              
                 CLKSEL    = 0x02;            // select PLL as sysclk src
                #endif
 178   1      
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 4   

 179   1      #elif defined(CPU_C8051F020)
              
                 XBR0 = 0x04;                 // Enable UART0 & UART1
                 XBR1 = 0x00;
                 XBR2 = 0x44;
              
                 /* Select external quartz oscillator */
                 OSCXCN = 0x67;               // Crystal mode, Power Factor 22E6
                 OSCICN = 0x08;               // CLKSL=1 (external)
              
              #elif defined(CPU_C8051F310) || defined(CPU_C8051F320)
              
                 XBR0 = 0x01;                 // Enable RX/TX
                 XBR1 = 0x40;                 // Enable crossbar
              
                 /* Select internal quartz oscillator */
                 OSCICN = 0x83;               // IOSCEN=1, SYSCLK=24.5 MHz
                 CLKSEL = 0x00;               // derive SYSCLK from internal source
              
              #else
              
                 XBR0 = 0x04;                 // Enable RX/TX
                 XBR1 = 0x00;
                 XBR2 = 0x40;                 // Enable crossbar
              
                 PRT0CF = 0x01;               // P0.0: TX = Push Pull
                 PRT1CF = 0x00;               // P1
                 PRT2CF = 0x00;               // P2  Open drain for 5V LCD
                 PRT3CF = 0x20;               // P3.5: RS485 enable = Push Pull
              
                 /* Select external quartz oscillator */
                 OSCXCN = 0x67;               // Crystal mode, Power Factor 22E6
                 OSCICN = 0x08;               // CLKSL=1 (external)
              
              #endif
 214   1              
 215   1      #ifdef CFG_HAVE_LCD
                 lcd_setup();
              #endif
 218   1      
 219   1      #ifdef CFG_HAVE_EMIF
                 /* initialize external memory interface */
                 d = emif_init();
              
                 /* do memory test on cold start */
                 SFRPAGE = LEGACY_PAGE;
                 if (d > 0 && (RSTSRC & 0x02) > 0)
                    emif_test(d);
              #endif
 228   1      
 229   1         /* start system clock */
 230   1         sysclock_init();
 231   1      
 232   1         /* enable watchdog with default timeout */
 233   1         watchdog_enable(0);
 234   1      
 235   1         /* enable missing clock detector */
 236   1         RSTSRC |= 0x04;
 237   1      
 238   1         /* default LED mode */
 239   1         for (i=0 ; i<N_LED ; i++)
 240   1            led_mode(i, 1);
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 5   

 241   1         
 242   1         /* initialize all memory */
 243   1         CSR = 0;
 244   1         addressed = 0;
 245   1         flash_param = 0;
 246   1         flash_program = 0;
 247   1         flash_allowed = 0;
 248   1         wrong_cpu = 0;
 249   1         _flkey = 0;
 250   1      
 251   1      #ifdef CFG_HAVE_RTC
                 rtc_set = 0;
              #endif
 254   1      
 255   1         i_in = i_out = n_out = 0;
 256   1         _cur_sub_addr = 0;
 257   1         for (i=0 ; i<sizeof(in_buf) ; i++)
 258   1            in_buf[i] = 0;
 259   1         for (i=0 ; i<sizeof(out_buf) ; i++)
 260   1            out_buf[i] = 0;
 261   1      
 262   1         /* check if we got reset by watchdog */
 263   1      #if defined(CPU_C8051F120)
 264   1         SFRPAGE   = LEGACY_PAGE;
 265   1      #endif
 266   1         WD_RESET = ((RSTSRC & 0x02) == 0 && (RSTSRC & 0x08) > 0);
 267   1      
 268   1         /* initialize UART(s) */
 269   1         uart_init(0, BD_115200);
 270   1      
 271   1      #ifdef CFG_UART1_MSCB
                 uart_init(1, BD_115200);
              #endif
 274   1      
 275   1      #ifdef CFG_DYN_VARIABLES
                 setup_variables();
              #endif
 278   1      
 279   1         /* count variables */
 280   1         for (n_variables = _var_size = 0;; n_variables++) {
 281   2            _var_size += variables[n_variables].width;
 282   2            if (variables[n_variables].width == 0)
 283   2               break;
 284   2         }
 285   1      
 286   1         /* check if variables are in xdata and xdata is present */
 287   1         if (n_variables > 0) {
 288   2            p = variables[0].ud;
 289   2            d = *p;
 290   2            *p = 0x55;
 291   2            if (*p != 0x55)
 292   2               wrong_cpu = 1;
 293   2            *p = 0xAA;
 294   2            if (*p != 0xAA)
 295   2               wrong_cpu = 1;
 296   2            *p = d;
 297   2         }
 298   1      
 299   1         /* retrieve EEPROM data */
 300   1      #ifdef CPU_C8051F120
 301   1         SFRPAGE = LEGACY_PAGE;
 302   1      #endif
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 6   

 303   1         if ((RSTSRC & 0x02) > 0)
 304   1            flags = eeprom_retrieve(1); // vars on cold start
 305   1         else
 306   1            flags = eeprom_retrieve(0);
 307   1      
 308   1         if ((flags & (1 << 0)) == 0) {
 309   2            configured_addr = 0;
 310   2         
 311   2            /* set initial values */
 312   2            sys_info.node_addr = 0xFFFF;
 313   2            sys_info.group_addr = 0xFFFF;
 314   2            memset(sys_info.node_name, 0, sizeof(sys_info.node_name));
 315   2            strncpy(sys_info.node_name, node_name, sizeof(sys_info.node_name));
 316   2         } else
 317   1            configured_addr = 1;
 318   1      
 319   1         /* store SVN revision */
 320   1         sys_info.svn_revision = (svn_rev_main[6]-'0')*1000+
 321   1                                 (svn_rev_main[7]-'0')*100+
 322   1                                 (svn_rev_main[8]-'0')*10+
 323   1                                 (svn_rev_main[9]-'0');
 324   1      
 325   1         if ((flags & (1 << 1)) == 0) {
 326   2      
 327   2            /* init variables */
 328   2            for (i = 0; variables[i].width; i++)
 329   2               if (!(variables[i].flags & MSCBF_DATALESS)) {
 330   3                  /* do it for each sub-address */
 331   3                  for (adr = 0 ; adr < _n_sub_addr ; adr++) {
 332   4                     memset((char*)variables[i].ud + _var_size*adr, 0, variables[i].width);
 333   4                  }
 334   3               }
 335   2      
 336   2            /* call user initialization routine with initialization */
 337   2            user_init(1);
 338   2      
 339   2            /* write current variables to flash later in main routine */
 340   2            configured_vars = 0;
 341   2         } else {
 342   2            /* call user initialization routine without initialization */
 343   2            user_init(0);
 344   2            configured_vars = 1;
 345   2         }
 346   1      
 347   1         /* Blink LEDs */
 348   1         for (i=0 ; i<N_LED ; i++)
 349   1            led_blink(i, 3, 150);
 350   1      
 351   1      }
 352          
 353          /*------------------------------------------------------------------*/
 354          
 355          unsigned char cur_sub_addr()
 356          {
 357   1         return _cur_sub_addr;
 358   1      }
 359          
 360          /*------------------------------------------------------------------*\
 361          
 362            Serial interrupt
 363          
 364          \*------------------------------------------------------------------*/
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 7   

 365          
 366          void interprete(void);
 367          
 368          void serial_int(void) interrupt 4 
 369          {
 370   1         if (TI0) {
 371   2            /* character has been transferred */
 372   2      
 373   2            TI0 = 0;                   // clear TI flag
 374   2      
 375   2            i_out++;                   // increment output counter
 376   2            if (i_out == n_out) {
 377   3               i_out = n_out = 0;      // send buffer empty, clear pointer
 378   3               DELAY_US(10);
 379   3               RS485_ENABLE = RS485_ENABLE_OFF; // disable RS485 driver
 380   3            } else {
 381   3               DELAY_US(INTERCHAR_DELAY);
 382   3               SBUF0 = out_buf[i_out]; // send character
 383   3            }
 384   2         }
 385   1      
 386   1         if (RI0) {
 387   2            /* character has been received */
 388   2      
 389   2            if (!RB80 && !addressed) {
 390   3               RI0 = 0;
 391   3               i_in = 0;
 392   3               return;                // discard data if not bit9 and not addressed
 393   3            }
 394   2      
 395   2            RB80 = 0;
 396   2            in_buf[i_in++] = SBUF0;
 397   2            RI0 = 0;
 398   2      
 399   2            if (i_in == 1) {
 400   3               /* check for padding character */
 401   3               if (in_buf[0] == 0) {
 402   4                  i_in = 0;
 403   4                  return;
 404   4               }
 405   3      
 406   3               /* initialize command length if first byte */
 407   3               cmd_len = (in_buf[0] & 0x07) + 2;    // + cmd + crc
 408   3            }
 409   2      
 410   2            if (i_in == 2 && cmd_len == 9) {
 411   3               /* variable length command */
 412   3               cmd_len = in_buf[1] + 3;             // + cmd + N + crc
 413   3            }
 414   2      
 415   2            if (i_in == sizeof(in_buf)) {   // check for buffer overflow
 416   3               i_in = 0;
 417   3               return;                      // don't interprete command
 418   3            }
 419   2      
 420   2            if (i_in < cmd_len)             // return if command not yet complete
 421   2               return;
 422   2      
 423   2            if (in_buf[i_in - 1] != crc8(in_buf, i_in - 1)) {
 424   3               i_in = 0;
 425   3               return;                      // return if CRC code does not match
 426   3            }
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 8   

 427   2      
 428   2            DELAY_US(INTERCHAR_DELAY);
 429   2      
 430   2            interprete();             // interprete command
 431   2            i_in = 0;
 432   2         }
 433   1      }
 434          
 435          /*------------------------------------------------------------------*\
 436          
 437            Interprete MSCB command
 438          
 439          \*------------------------------------------------------------------*/
 440          
 441          #pragma NOAREGS
 442          
 443          #include <intrins.h>
 444          
 445          static void send_byte(unsigned char d, unsigned char *crc)
 446          {
 447   1      #ifdef CPU_C8051F120
 448   1         SFRPAGE = UART0_PAGE;
 449   1      #endif
 450   1      
 451   1         if (crc)
 452   1            *crc = crc8_add(*crc, d);
 453   1         DELAY_US(INTERCHAR_DELAY);
 454   1         SBUF0 = d;
 455   1         watchdog_refresh(1);
 456   1         while (!TI0);
 457   1         TI0 = 0;
 458   1      }
 459          
 460          static void send_obuf(unsigned char n)
 461          {
 462   1      #ifdef CPU_C8051F120
 463   1         SFRPAGE = UART0_PAGE;
 464   1      #endif
 465   1      
 466   1         n_out = n;
 467   1         RS485_ENABLE = RS485_ENABLE_ON;
 468   1         DELAY_US(INTERCHAR_DELAY);
 469   1         SBUF0 = out_buf[0];
 470   1      }
 471          
 472          void addr_node8(unsigned char mode, unsigned char adr, unsigned char node_addr)
 473          {
 474   1         if (mode == ADDR_NODE) {
 475   2            if (adr >= node_addr &&
 476   2                adr <  node_addr + _n_sub_addr) {
 477   3      
 478   3               addressed = 1;
 479   3               _cur_sub_addr = adr - node_addr;
 480   3               addr_mode = ADDR_NODE;
 481   3            } else {
 482   3               addressed = 0;
 483   3               addr_mode = ADDR_NONE;
 484   3            }
 485   2         } else if (mode == ADDR_GROUP) {
 486   2            if (adr == node_addr) {
 487   3               addressed = 1;
 488   3               _cur_sub_addr = 0;
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 9   

 489   3               addr_mode = ADDR_GROUP;
 490   3            } else {
 491   3               addressed = 0;
 492   3               addr_mode = ADDR_NONE;
 493   3            }
 494   2         }
 495   1      }
 496          
 497          void addr_node16(unsigned char mode, unsigned int adr, unsigned int node_addr)
 498          {
 499   1         if (node_addr == 0xFFFF) {
 500   2            if (adr == node_addr) {
 501   3               addressed = 1;
 502   3               _cur_sub_addr = 0;
 503   3               addr_mode = mode;
 504   3            } else {
 505   3               addressed = 0;
 506   3               addr_mode = ADDR_NONE;
 507   3            }
 508   2         } else {
 509   2            if (mode == ADDR_NODE) {
 510   3               if (adr >= node_addr &&
 511   3                   adr <  node_addr + _n_sub_addr) {
 512   4         
 513   4                  addressed = 1;
 514   4                  _cur_sub_addr = adr - node_addr;
 515   4                  addr_mode = ADDR_NODE;
 516   4               } else {
 517   4                  addressed = 0;
 518   4                  addr_mode = ADDR_NONE;
 519   4               }
 520   3            } else if (mode == ADDR_GROUP) {
 521   3               if (adr == node_addr) {
 522   4                  addressed = 1;
 523   4                  _cur_sub_addr = 0;
 524   4                  addr_mode = ADDR_GROUP;
 525   4               } else {
 526   4                  addressed = 0;
 527   4                  addr_mode = ADDR_NONE;
 528   4               }
 529   3            }
 530   2         }
 531   1      }
 532          
 533          void interprete(void) 
 534          {
 535   1         unsigned char crc, cmd, i, j, n, ch, ch1, ch2, a1, a2;
 536   1         unsigned short size;
 537   1         MSCB_INFO_VAR *pvar;
 538   1         unsigned long idata u;
 539   1      
 540   1         cmd = (in_buf[0] & 0xF8);    // strip length field
 541   1      
 542   1      #ifdef CPU_C8051F120
 543   1         SFRPAGE = UART0_PAGE;        // needed for SBUF0
 544   1      #endif
 545   1      
 546   1         switch (in_buf[0]) {
 547   2         case CMD_ADDR_NODE8:
 548   2            addr_node8(ADDR_NODE, in_buf[1], sys_info.node_addr & 0xFF);
 549   2            break;
 550   2      
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 10  

 551   2         case CMD_ADDR_NODE16:
 552   2            addr_node16(ADDR_NODE, *(unsigned int *) &in_buf[1], sys_info.node_addr);
 553   2            break;
 554   2      
 555   2         case CMD_ADDR_BC:
 556   2            addressed = 1;
 557   2            addr_mode = ADDR_ALL;
 558   2            break;
 559   2      
 560   2         case CMD_ADDR_GRP8:
 561   2            addr_node8(ADDR_GROUP, in_buf[1], sys_info.group_addr & 0xFF);
 562   2            break;
 563   2      
 564   2         case CMD_ADDR_GRP16:
 565   2            addr_node16(ADDR_GROUP, *(unsigned int *) &in_buf[1], sys_info.group_addr);
 566   2            break;
 567   2      
 568   2         case CMD_PING8:
 569   2            addr_node8(ADDR_NODE, in_buf[1], sys_info.node_addr & 0xFF);
 570   2            if (addressed) {
 571   3               out_buf[0] = CMD_ACK;
 572   3               send_obuf(1);
 573   3            }
 574   2            break;
 575   2      
 576   2         case CMD_PING16:
 577   2            addr_node16(ADDR_NODE, *(unsigned int *) &in_buf[1], sys_info.node_addr);
 578   2            if (addressed) {
 579   3               out_buf[0] = CMD_ACK;
 580   3               send_obuf(1);
 581   3            }
 582   2            break;
 583   2      
 584   2         case CMD_INIT:
 585   2      #ifdef CPU_C8051F120
 586   2            SFRPAGE = LEGACY_PAGE;
 587   2      #endif
 588   2      
 589   2            RSTSRC = 0x10;         // force software reset
 590   2            break;
 591   2      
 592   2         case CMD_GET_INFO:
 593   2            /* general info */
 594   2      
 595   2            ES0 = 0;                  // temporarily disable serial interrupt
 596   2            crc = 0;
 597   2            RS485_ENABLE = RS485_ENABLE_ON;
 598   2      
 599   2            send_byte(CMD_ACK + 7, &crc);      // send acknowledge, variable data length
 600   2      #ifdef CFG_HAVE_RTC
                    send_byte(30, &crc);               // send data length
              #else
 603   2            send_byte(24, &crc);               // send data length
 604   2      #endif
 605   2            send_byte(PROTOCOL_VERSION, &crc); // send protocol version
 606   2      
 607   2            send_byte(n_variables, &crc);      // send number of variables
 608   2      
 609   2            send_byte(*(((unsigned char *) &sys_info.node_addr) + 0), &crc);  // send node address
 610   2            send_byte(*(((unsigned char *) &sys_info.node_addr) + 1), &crc);
 611   2      
 612   2            send_byte(*(((unsigned char *) &sys_info.group_addr) + 0), &crc); // send group address
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 11  

 613   2            send_byte(*(((unsigned char *) &sys_info.group_addr) + 1), &crc);
 614   2      
 615   2            send_byte(*(((unsigned char *) &sys_info.svn_revision) + 0), &crc);   // send svn revision
 616   2            send_byte(*(((unsigned char *) &sys_info.svn_revision) + 1), &crc);
 617   2      
 618   2            for (i = 0; i < 16; i++)  // send node name
 619   2               send_byte(sys_info.node_name[i], &crc);
 620   2      
 621   2      #ifdef CFG_HAVE_RTC
                    for (i = 0; i < 6 ; i++)
                       send_byte(rtc_bread[i], &crc);
              #endif
 625   2      
 626   2            send_byte(crc, NULL);     // send CRC code
 627   2      
 628   2            DELAY_US(10);
 629   2            RS485_ENABLE = RS485_ENABLE_OFF;
 630   2            ES0 = 1;                  // re-enable serial interrupts
 631   2            break;
 632   2      
 633   2         case CMD_GET_INFO + 1:
 634   2            /* send variable info */
 635   2      
 636   2            if (in_buf[1] < n_variables) {
 637   3               pvar = variables + in_buf[1];
 638   3                                        
 639   3               ES0 = 0;                       // temporarily disable serial interrupt
 640   3               crc = 0;
 641   3               RS485_ENABLE = RS485_ENABLE_ON;
 642   3      
 643   3               send_byte(CMD_ACK + 7, &crc);  // send acknowledge, variable data length
 644   3               send_byte(13, &crc);           // send data length
 645   3               send_byte(pvar->width, &crc);
 646   3               send_byte(pvar->unit, &crc);
 647   3               send_byte(pvar->prefix, &crc);
 648   3               send_byte(pvar->status, &crc);
 649   3               send_byte(pvar->flags, &crc);
 650   3      
 651   3               for (i = 0; i < 8; i++)        // send variable name
 652   3                  send_byte(pvar->name[i], &crc);
 653   3      
 654   3               send_byte(crc, NULL);          // send CRC code
 655   3      
 656   3               DELAY_US(10);
 657   3               RS485_ENABLE = RS485_ENABLE_OFF;
 658   3               ES0 = 1;                       // re-enable serial interrupts
 659   3            } else {
 660   3               /* just send dummy ack */
 661   3               out_buf[0] = CMD_ACK;
 662   3               out_buf[1] = 0;
 663   3               send_obuf(2);
 664   3            }
 665   2      
 666   2            break;
 667   2      
 668   2         case CMD_GET_UPTIME:
 669   2            /* send uptime */
 670   2      
 671   2            u = uptime();
 672   2      
 673   2            out_buf[0] = CMD_ACK + 4;
 674   2            out_buf[1] = *(((unsigned char *)&u) + 0);
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 12  

 675   2            out_buf[2] = *(((unsigned char *)&u) + 1);
 676   2            out_buf[3] = *(((unsigned char *)&u) + 2);
 677   2            out_buf[4] = *(((unsigned char *)&u) + 3);
 678   2            out_buf[5] = crc8(out_buf, 5);
 679   2            send_obuf(6);
 680   2            break;
 681   2      
 682   2         case CMD_SET_ADDR:
 683   2      
 684   2            if (in_buf[1] == ADDR_SET_NODE) 
 685   2               /* complete node address */
 686   2               sys_info.node_addr = *((unsigned int *) (in_buf + 2));
 687   2            else if (in_buf[1] == ADDR_SET_HIGH)
 688   2               /* only high byte node address */
 689   2               *((unsigned char *)(&sys_info.node_addr)) = *((unsigned char *) (in_buf + 2));
 690   2            else if (in_buf[1] == ADDR_SET_GROUP)
 691   2               /* group address */
 692   2               sys_info.group_addr = *((unsigned int *) (in_buf + 2));
 693   2      
 694   2            /* copy address to EEPROM */
 695   2            flash_param = 1;
 696   2            _flkey = 0xF1;
 697   2      
 698   2            break;
 699   2      
 700   2         case CMD_SET_NAME:
 701   2            /* set node name in RAM */
 702   2            for (i = 0; i < 16 && i < in_buf[1]; i++)
 703   2               sys_info.node_name[i] = in_buf[2 + i];
 704   2            sys_info.node_name[15] = 0;
 705   2      
 706   2            /* copy address to EEPROM */
 707   2            flash_param = 1;
 708   2            _flkey = 0xF1;
 709   2      
 710   2            break;
 711   2      
 712   2         case CMD_SET_BAUD:
 713   2            led_blink(_cur_sub_addr, 1, 50);
 714   2            uart_init(0, in_buf[1]);
 715   2            break;
 716   2      
 717   2         case CMD_FREEZE:
 718   2            FREEZE_MODE = in_buf[1];
 719   2            break;
 720   2      
 721   2         case CMD_SYNC:
 722   2            SYNC_MODE = in_buf[1];
 723   2            break;
 724   2      
 725   2         case CMD_SET_TIME:
 726   2      #ifdef CFG_HAVE_RTC
                    led_blink(0, 1, 50);
                    for (i=0 ; i<6 ; i++)
                       rtc_bwrite[i] = in_buf[i+1];
                    rtc_set = 1;
              #endif
 732   2            break;
 733   2      
 734   2         case CMD_UPGRADE:
 735   2            if (_cur_sub_addr != 0)
 736   2               n = 2; // reject upgrade for sub address
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 13  

 737   2            else if (flash_allowed == 0)
 738   2               n = 3; // upgrade not yet allowed
 739   2            else
 740   2               n = 1; // positive acknowledge
 741   2      
 742   2            out_buf[0] = CMD_ACK + 1;
 743   2            out_buf[1] = n;
 744   2            out_buf[2] = crc8(out_buf, 2);
 745   2            send_obuf(3);
 746   2      
 747   2            if (n == 1) {
 748   3               flash_program = 1;
 749   3               _flkey = 0xF1;
 750   3            }
 751   2            break;
 752   2      
 753   2         case CMD_FLASH:
 754   2            flash_param = 1;
 755   2            _flkey = 0xF1;
 756   2            break;
 757   2      
 758   2         case CMD_ECHO:
 759   2            led_blink(0, 1, 50);
 760   2            out_buf[0] = CMD_ACK + 1;
 761   2            out_buf[1] = in_buf[1];
 762   2            out_buf[2] = crc8(out_buf, 2);
 763   2            send_obuf(3);
 764   2            break;
 765   2      
 766   2         }
 767   1      
 768   1         if (cmd == CMD_READ) {
 769   2            if (in_buf[0] == CMD_READ + 1) {  // single variable
 770   3               if (in_buf[1] < n_variables) {
 771   4                  n = variables[in_buf[1]].width;     // number of bytes to return
 772   4      
 773   4                  if (variables[in_buf[1]].flags & MSCBF_DATALESS) {
 774   5                     n = user_read(in_buf[1]);        // for dataless variables, user routine returns bytes
 775   5                     out_buf[0] = CMD_ACK + 7;        // and places data directly in out_buf
 776   5                     out_buf[1] = n;
 777   5      
 778   5                     out_buf[2 + n] = crc8(out_buf, 2 + n);      // generate CRC code
 779   5         
 780   5                     /* send result */
 781   5                     send_obuf(3 + n);
 782   5      
 783   5                  } else {
 784   5      
 785   5                     user_read(in_buf[1]);
 786   5      
 787   5                     ES0 = 0;            // temporarily disable serial interrupt
 788   5                     crc = 0;
 789   5                     RS485_ENABLE = RS485_ENABLE_ON;
 790   5         
 791   5                     if (n > 6) {
 792   6                        /* variable length buffer */
 793   6                        send_byte(CMD_ACK + 7, &crc);       // send acknowledge, variable data length
 794   6                        send_byte(n, &crc);                 // send data length
 795   6      
 796   6                        for (i = 0; i < n; i++)             // copy user data
 797   6                           send_byte(((char *) variables[in_buf[1]].ud)[i+_var_size*_cur_sub_addr], &crc);
 798   6                        n++;
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 14  

 799   6                     } else {
 800   6      
 801   6                        send_byte(CMD_ACK + n, &crc);       // send acknowledge
 802   6                     
 803   6                        for (i = 0; i < n; i++)             // copy user data
 804   6                           send_byte(((char *) variables[in_buf[1]].ud)[i+_var_size*_cur_sub_addr], &crc);
 805   6                     }
 806   5      
 807   5                     send_byte(crc, NULL);                  // send CRC code
 808   5         
 809   5                     DELAY_US(10);
 810   5                     RS485_ENABLE = RS485_ENABLE_OFF;
 811   5                     ES0 = 1;            // re-enable serial interrupts
 812   5                  }
 813   4               } else {
 814   4                  /* just send dummy ack to indicate error */
 815   4                  out_buf[0] = CMD_ACK;
 816   4                  send_obuf(1);
 817   4               }  
 818   3      
 819   3            } else if (in_buf[0] == CMD_READ + 2) {   // variable range
 820   3      
 821   3              if (in_buf[1] < n_variables && in_buf[2] < n_variables && in_buf[1] <= in_buf[2]) {
 822   4                  /* calculate number of bytes to return */
 823   4                  for (i = in_buf[1], size = 0; i <= in_buf[2]; i++) {
 824   5                     user_read(i);
 825   5                     size += variables[i].width;
 826   5                  }
 827   4      
 828   4                  ES0 = 0;            // temporarily disable serial interrupt
 829   4                  crc = 0;
 830   4                  RS485_ENABLE = RS485_ENABLE_ON;
 831   4      
 832   4                  send_byte(CMD_ACK + 7, &crc);            // send acknowledge, variable data length
 833   4                  if (size < 0x80)
 834   4                     send_byte(size, &crc);                // send data length one byte
 835   4                  else {
 836   5                     send_byte(0x80 | size / 0x100, &crc); // send data length two bytes
 837   5                     send_byte(size & 0xFF, &crc);
 838   5                  }
 839   4      
 840   4                  /* loop over all variables */
 841   4                  for (i = in_buf[1]; i <= in_buf[2]; i++) {
 842   5                     for (j = 0; j < variables[i].width; j++)    // send user data
 843   5                        send_byte(((char *) variables[i].ud)[j+_var_size*_cur_sub_addr], &crc); 
 844   5                  }
 845   4      
 846   4                  send_byte(crc, NULL);       // send CRC code
 847   4      
 848   4                  DELAY_US(10);
 849   4                  RS485_ENABLE = RS485_ENABLE_OFF;
 850   4                  ES0 = 1;            // re-enable serial interrupts
 851   4               } else {
 852   4                  /* just send dummy ack to indicate error */
 853   4                  out_buf[0] = CMD_ACK;
 854   4                  send_obuf(1);
 855   4               }
 856   3            }
 857   2         }
 858   1      
 859   1         if (cmd == CMD_USER) {
 860   2            led_blink(_cur_sub_addr, 1, 50);
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 15  

 861   2            n = user_func(in_buf + 1, out_buf + 1);
 862   2            out_buf[0] = CMD_ACK + n;
 863   2            out_buf[n + 1] = crc8(out_buf, n + 1);
 864   2            send_obuf(n+2);
 865   2         }
 866   1      
 867   1         if (cmd == CMD_WRITE_NA || cmd == CMD_WRITE_ACK) {
 868   2      
 869   2            /* blink LED once when writing data */
 870   2            if (addr_mode == ADDR_NODE)
 871   2               led_blink(_cur_sub_addr, 1, 50);
 872   2            else 
 873   2               for (i=0 ; i<_n_sub_addr ; i++)
 874   2                  led_blink(i, 1, 50);
 875   2      
 876   2            n = in_buf[0] & 0x07;
 877   2      
 878   2            if (n == 0x07) {  // variable length
 879   3               j = 1;
 880   3               n = in_buf[1];
 881   3               ch = in_buf[2];
 882   3            } else {
 883   3               j = 0;
 884   3               ch = in_buf[1];
 885   3            }
 886   2      
 887   2            n--; // data size (minus channel)
 888   2      
 889   2            if (ch < n_variables) {
 890   3         
 891   3               /* don't exceed variable width */
 892   3               if (n > variables[ch].width)
 893   3                  n = variables[ch].width;
 894   3      
 895   3               if (addr_mode == ADDR_NODE)
 896   3                  a1 = a2 = _cur_sub_addr;
 897   3               else {
 898   4                  a1 = 0;
 899   4                  a2 = _n_sub_addr-1;
 900   4               }
 901   3                  
 902   3               for (_cur_sub_addr = a1 ; _cur_sub_addr <= a2 ; _cur_sub_addr++) {
 903   4                  for (i = 0; i < n; i++)
 904   4                     if (!(variables[ch].flags & MSCBF_DATALESS)) {
 905   5                        if (variables[ch].unit == UNIT_STRING) {
 906   6                           if (n > 4)
 907   6                              /* copy bytes in normal order */
 908   6                              ((char *) variables[ch].ud)[i + _var_size*_cur_sub_addr] = 
 909   6                                 in_buf[2 + j + i];
 910   6                           else
 911   6                              /* copy bytes in reverse order (got swapped on host) */
 912   6                              ((char *) variables[ch].ud)[i + _var_size*_cur_sub_addr] = 
 913   6                                 in_buf[i_in - 2 - i];
 914   6                        } else
 915   5                           /* copy LSB bytes, needed for BYTE if DWORD is sent */
 916   5                           ((char *) variables[ch].ud)[i + _var_size*_cur_sub_addr] = 
 917   5                                 in_buf[i_in - 1 - variables[ch].width + i + j];
 918   5                     }
 919   4         
 920   4                  user_write(ch);
 921   4               }
 922   3               _cur_sub_addr = a1; // restore previous value
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 16  

 923   3         
 924   3      #ifdef CFG_UART1_MSCB
                       /* mark variable to be send in main loop */
                       if (variables[ch].flags & MSCBF_REMOUT)
                          var_to_send = ch;
              #endif
 929   3      
 930   3               if (cmd == CMD_WRITE_ACK) {
 931   4                  out_buf[0] = CMD_ACK;
 932   4                  out_buf[1] = in_buf[i_in - 1];
 933   4                  send_obuf(2);
 934   4               }
 935   3            } else if (ch == 0xFF) {
 936   3               CSR = in_buf[2];
 937   3      
 938   3               if (cmd == CMD_WRITE_ACK) {
 939   4                  out_buf[0] = CMD_ACK;
 940   4                  out_buf[1] = in_buf[i_in - 1];
 941   4                  send_obuf(2);
 942   4               }
 943   3            }
 944   2         }
 945   1      
 946   1      
 947   1         if (cmd == CMD_WRITE_RANGE) {
 948   2      
 949   2            /* blink LED once when writing data */
 950   2            if (addr_mode == ADDR_NODE)
 951   2               led_blink(_cur_sub_addr, 1, 50);
 952   2            else 
 953   2               for (i=0 ; i<_n_sub_addr ; i++)
 954   2                  led_blink(i, 1, 50);
 955   2      
 956   2            if (in_buf[1] & 0x80) {
 957   3               size = (in_buf[1] & 0x7F) << 8 | in_buf[2];
 958   3               j = 3;
 959   3            } else {
 960   3               size = in_buf[1];
 961   3               j = 2;
 962   3            }
 963   2      
 964   2            ch1 = in_buf[j];
 965   2            ch2 = in_buf[j+1];
 966   2            for (ch = ch1 ; ch <= ch2 ; ch++) {
 967   3               if (ch < n_variables) {
 968   4            
 969   4                  n = variables[ch].width;
 970   4      
 971   4                  if (addr_mode == ADDR_NODE)
 972   4                     a1 = a2 = _cur_sub_addr;
 973   4                  else {
 974   5                     a1 = 0;
 975   5                     a2 = _n_sub_addr-1;
 976   5                  }
 977   4                     
 978   4                  for (_cur_sub_addr = a1 ; _cur_sub_addr <= a2 ; _cur_sub_addr++) {
 979   5                     for (i = 0; i < n; i++)
 980   5                        if (!(variables[ch].flags & MSCBF_DATALESS)) {
 981   6                           ((char *) variables[ch].ud)[i + _var_size*_cur_sub_addr] = 
 982   6                              in_buf[2 + j + i];
 983   6                        }
 984   5            
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 17  

 985   5                     user_write(ch);
 986   5                  }
 987   4                  _cur_sub_addr = a1; // restore previous value
 988   4                  j += n;
 989   4               }
 990   3            }
 991   2            out_buf[0] = CMD_ACK;
 992   2            out_buf[1] = in_buf[i_in - 1];
 993   2            send_obuf(2);
 994   2         }
 995   1      
 996   1      }
 997          
 998          /*------------------------------------------------------------------*/
 999          
1000          #ifdef CFG_UART1_MSCB
              
              static unsigned short xdata last_addr = -1;
              static unsigned char xdata uart1_buf[10];
              
              /*------------------------------------------------------------------*/
              
              void address_node(unsigned short addr)
              {
                 if (addr != last_addr) {
                    uart1_buf[0] = CMD_ADDR_NODE16;
                    uart1_buf[1] = (unsigned char) (addr >> 8);
                    uart1_buf[2] = (unsigned char) (addr & 0xFF);
                    uart1_buf[3] = crc8(uart1_buf, 3);
                    uart1_send(uart1_buf, 4, 1);
                    last_addr = addr;
                 }
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned char ping(unsigned short addr)
              {
                 unsigned char n;
              
                 uart1_buf[0] = CMD_PING16;
                 uart1_buf[1] = (unsigned char) (addr >> 8);
                 uart1_buf[2] = (unsigned char) (addr & 0xFF);
                 uart1_buf[3] = crc8(uart1_buf, 3);
                 uart1_send(uart1_buf, 4, 1);
              
                 n = uart1_receive(uart1_buf, 10);
                 if (n == 0)
                    return 0; // no response
              
                 if (uart1_buf[0] != CMD_ACK)
                    return 0; // invalid response
              
                 return 1; // node resonded
              }
              
              /*------------------------------------------------------------------*/
              
              void poll_error(unsigned char i)
              {
                 if (i);
                 led_blink(1, 1, 50);
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 18  

                 last_addr = -1; // force re-adressing of single node
              
                 /* flush input queue of remote device */
                 for (i=0 ; i<10 ; i++)
                    uart1_buf[i] = 0;
                 uart1_send(uart1_buf, 10, 1);
              }
              
              void poll_remote_vars()
              {
              unsigned char i, n;
              
                 for (i=0 ; i<n_variables ; i++)
                    if (variables[i].flags & MSCBF_REMIN) {
                       
                       address_node(variables[i].node_address);
              
                       /* read variable */
                       uart1_buf[0] = CMD_READ + 1;
                       uart1_buf[1] = variables[i].channel;
                       uart1_buf[2] = crc8(uart1_buf, 2);
                       uart1_send(uart1_buf, 3, 0);
              
                       n = uart1_receive(uart1_buf, 100);
              
                       if (n<2) {
                          poll_error(i);
                          continue; // no bytes receive
                       }
              
                       if (uart1_buf[0] != CMD_ACK + n - 2) {
                          poll_error(i);
                          continue; // invalid command received
                       }
              
                       if (variables[i].width != n - 2) {
                          poll_error(i);
                          continue; // variables has wrong length
                       }
              
                       if (uart1_buf[n-1] != crc8(uart1_buf, n-1)) {
                          poll_error(i);
                          continue; // invalid CRC
                       }
              
                       /* all ok, so copy variable */
                       DISABLE_INTERRUPTS;
                       memcpy(variables[i].ud, uart1_buf+1, variables[i].width);
                       ENABLE_INTERRUPTS;
                    }
              
              }
              
              /*------------------------------------------------------------------*/
              
              void send_remote_var(unsigned char i)
              {
              unsigned char size;
              
                 address_node(variables[i].node_address);
              
                 /* send variable */
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 19  

                 size = variables[i].width;
                 uart1_buf[0] = CMD_WRITE_NA + size + 1;
                 uart1_buf[1] = variables[i].channel;
                 memcpy(uart1_buf+2, variables[i].ud, size);
                 uart1_buf[2+size] = crc8(uart1_buf, 2+size);
                 uart1_send(uart1_buf, 3+size, 0);
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned long xdata last_poll = 0;
              
              void manage_remote_vars()
              {
                 /* read remote variables once every 10 ms */
                 if (time() > last_poll+10) {
                    poll_remote_vars();
                    last_poll = time();
                 }
              
                 /* send remote variables if changed */
                 if (var_to_send != 0xFF) {
                    send_remote_var(var_to_send);
                    var_to_send = 0xFF;
                 }
              }
              
              #endif // UART1_MSCB
1137          
1138          /*------------------------------------------------------------------*/
1139          
1140          #ifdef LED_0
1141          sbit led_0 = LED_0;
1142          #endif
1143          
1144          #define SEND_BYTE(_b) \
1145             TI0 = 0; \
1146             DELAY_US(INTERCHAR_DELAY); \
1147             SBUF0 = _b; \
1148             while (TI0 == 0);
1149          
1150          #pragma OT(8, SIZE) // 9 would call subroutines in program body -> crash on upgrade
1151          
1152          void upgrade()
1153          {
1154   1         unsigned char idata cmd, page, crc, j, k;
1155   1         unsigned short idata i;
1156   1         unsigned char xdata * idata pw;
1157   1         unsigned char code * idata pr;
1158   1      
1159   1         if (_flkey != 0xF1)
1160   1            return;
1161   1      
1162   1         /* wait for acknowledge to be sent */
1163   1         for (i=0 ; i<10000 ; i++) {
1164   2            if (n_out == 0)
1165   2               break;
1166   2            DELAY_US(10);
1167   2         }
1168   1      
1169   1         /* disable all interrupts */
1170   1         EA = 0;
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 20  

1171   1      #if defined(CPU_C8051F120)
1172   1         SFRPAGE = UART1_PAGE;
1173   1         SCON1 &= ~0x03; // clear pending UART1 interrupts
1174   1      #endif
1175   1      
1176   1         /* disable watchdog */
1177   1      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                 PCA0MD = 0x00;
              #else
1180   1         WDTCN = 0xDE;
1181   1         WDTCN = 0xAD;
1182   1      #endif
1183   1      
1184   1         cmd = page = 0;
1185   1      
1186   1         do {
1187   2      
1188   2      receive_cmd:
1189   2      
1190   2      #ifdef CPU_C8051F120
1191   2            SFRPAGE = UART0_PAGE;
1192   2      #endif
1193   2      
1194   2            /* receive command */
1195   2            while (!RI0) {
1196   3               for (i=0 ; !RI0 && i<5000 ; i++)
1197   3                  DELAY_US(10);
1198   3               led_0 = !led_0;
1199   3      #if defined(CFG_EXT_WATCHDOG) && defined(EXT_WATCHDOG_PIN)
                       EXT_WATCHDOG = !EXT_WATCHDOG;
              #endif
1202   3            }
1203   2      
1204   2            cmd = SBUF0;
1205   2            RI0 = 0;
1206   2      
1207   2      #if defined(CFG_EXT_WATCHDOG) && defined(EXT_WATCHDOG_PIN)
                    EXT_WATCHDOG = !EXT_WATCHDOG;
              #endif
1210   2      
1211   2            /* cannot use case since it calls the C library */
1212   2      
1213   2            if (cmd == CMD_PING16) {
1214   3      
1215   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1216   3                  DELAY_US(10);
1217   3               if (!RI0) 
1218   3                  goto receive_cmd;
1219   3               page = SBUF0; // LSB
1220   3               RI0 = 0;
1221   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1222   3                  DELAY_US(10);
1223   3               if (!RI0) 
1224   3                  goto receive_cmd;
1225   3               page = SBUF0; // MSB
1226   3               RI0 = 0;
1227   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1228   3                  DELAY_US(10);
1229   3               if (!RI0) 
1230   3                  goto receive_cmd;
1231   3               page = SBUF0; // CRC
1232   3               RI0 = 0;
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 21  

1233   3      
1234   3               /* acknowledge ping, independent of own address */
1235   3               RS485_ENABLE = RS485_ENABLE_ON;
1236   3               SEND_BYTE(CMD_ACK);
1237   3               DELAY_US(10);
1238   3               RS485_ENABLE = RS485_ENABLE_OFF;
1239   3      
1240   3            } else if (cmd == CMD_UPGRADE) {
1241   3      
1242   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1243   3                  DELAY_US(10);
1244   3               if (!RI0) 
1245   3                  goto receive_cmd;
1246   3               page = SBUF0; // CRC
1247   3               RI0 = 0;
1248   3      
1249   3               /* acknowledge upgrade */
1250   3               RS485_ENABLE = RS485_ENABLE_ON;
1251   3               SEND_BYTE(CMD_ACK+1);
1252   3               SEND_BYTE(1);
1253   3               SEND_BYTE(0); // dummy CRC
1254   3               DELAY_US(10);
1255   3               RS485_ENABLE = RS485_ENABLE_OFF;
1256   3      
1257   3            } else if (cmd == UCMD_ECHO) {
1258   3      
1259   3               RS485_ENABLE = RS485_ENABLE_ON;
1260   3               SEND_BYTE(CMD_ACK);
1261   3               SEND_BYTE(0); // dummy CRC, needed by subm_250
1262   3               DELAY_US(10);
1263   3               RS485_ENABLE = RS485_ENABLE_OFF;
1264   3      
1265   3            } else if (cmd == UCMD_ERASE) {
1266   3      
1267   3               /* receive page */
1268   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1269   3                  DELAY_US(10);
1270   3               if (!RI0) 
1271   3                  goto receive_cmd;
1272   3      
1273   3               page = SBUF0;
1274   3               RI0 = 0;
1275   3               crc = 0;
1276   3      
1277   3               led_0 = !(page & 1);
1278   3      
1279   3               /* erase page if not page of upgrade() function */
1280   3               if (page*512 < (unsigned int)upgrade && page*512 < EEPROM_OFFSET) {
1281   4      
1282   4      #ifdef CPU_C8051F120
1283   4                  /* for F120, only erase even pages (1024kB page size!) */
1284   4                  if (page & 1)
1285   4                     goto erase_ok;
1286   4      
1287   4                  SFRPAGE = LEGACY_PAGE;
1288   4      #endif
1289   4      
1290   4      #if defined(CPU_C8051F000)
                          FLSCL = (FLSCL & 0xF0) | 0x08; // set timer for 11.052 MHz clock
              #elif defined (CPU_C8051F020) || defined(CPU_C8051F120)
1293   4                  FLSCL = FLSCL | 1;     // enable flash writes
1294   4      #endif
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 22  

1295   4                  PSCTL = 0x03;          // allow write and erase
1296   4         
1297   4                  pw = (char xdata *) (512 * page);
1298   4         
1299   4      #if defined(CPU_C8051F310) || defined (CPU_C8051F320)
                          FLKEY = 0xA5;          // write flash key code
                          FLKEY = _flkey;
              #endif
1303   4                  
1304   4                  *pw = 0;
1305   4         
1306   4      #if !defined(CPU_C8051F310) && !defined(CPU_C8051F320)
1307   4                  FLSCL = (FLSCL & 0xF0);
1308   4      #endif
1309   4                  PSCTL = 0x00;
1310   4      
1311   4               } else {
1312   4                  crc = 0xFF;            // return 'protected' flag
1313   4               }
1314   3      
1315   3      #ifdef CPU_C8051F120
1316   3               SFRPAGE = UART0_PAGE;
1317   3      #endif
1318   3      
1319   3      #ifdef CPU_C8051F120
1320   3      erase_ok:
1321   3      #endif
1322   3               /* return acknowledge */
1323   3               RS485_ENABLE = RS485_ENABLE_ON;
1324   3               SEND_BYTE(CMD_ACK);
1325   3               SEND_BYTE(crc);
1326   3               DELAY_US(10);
1327   3               RS485_ENABLE = RS485_ENABLE_OFF;
1328   3      
1329   3            } else if (cmd == UCMD_PROGRAM) {
1330   3      
1331   3               /* receive page */
1332   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1333   3                  DELAY_US(10);
1334   3               if (!RI0) 
1335   3                  goto receive_cmd;
1336   3               page = SBUF0;
1337   3               RI0 = 0;
1338   3      
1339   3               /* receive subpage */
1340   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1341   3                  DELAY_US(10);
1342   3               if (!RI0) 
1343   3                  goto receive_cmd;
1344   3               j = SBUF0;
1345   3               RI0 = 0;
1346   3      
1347   3               led_0 = page & 1;
1348   3      
1349   3               /* program page if not page of upgrade() function */
1350   3               if (page*512 >= (unsigned int)upgrade || page*512 >= EEPROM_OFFSET)
1351   3                  goto receive_cmd;
1352   3      
1353   3      #ifdef CPU_C8051F120
1354   3               SFRPAGE = LEGACY_PAGE;
1355   3      #endif
1356   3      
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 23  

1357   3               /* allow write */
1358   3      #if defined(CPU_C8051F000)
                       FLSCL = (FLSCL & 0xF0) | 0x08; // set timer for 11.052 MHz clock
              #elif defined (CPU_C8051F020) || defined(CPU_C8051F120)
1361   3               FLSCL = FLSCL | 1;        // enable flash writes
1362   3      #endif
1363   3               PSCTL = 0x01;             // allow write access
1364   3      
1365   3               pw = (char xdata *) (page*512 + j*32);
1366   3      
1367   3      #ifdef CPU_C8051F120
1368   3               SFRPAGE = UART0_PAGE;
1369   3      #endif
1370   3      
1371   3               /* receive 32 bytes */
1372   3               for (k = 0; k < 32; k++) {
1373   4                  for (i=0 ; !RI0 && i < 5000 ; i++)
1374   4                     DELAY_US(10);
1375   4                  if (!RI0) 
1376   4                     goto receive_cmd;
1377   4      
1378   4      #if defined(CPU_C8051F310) || defined (CPU_C8051F320)
                          FLKEY = 0xA5;          // write flash key code
                          FLKEY = _flkey;
              #endif
1382   4                  /* flash byte */
1383   4                  *pw++ = SBUF0;
1384   4                  RI0 = 0;
1385   4               }
1386   3      
1387   3      #ifdef CPU_C8051F120
1388   3               SFRPAGE = LEGACY_PAGE;
1389   3      #endif
1390   3      
1391   3               /* disable write */
1392   3      #if !defined(CPU_C8051F310) && !defined(CPU_C8051F320)
1393   3               FLSCL = (FLSCL & 0xF0);
1394   3      #endif
1395   3               PSCTL = 0x00;
1396   3      
1397   3      #ifdef CPU_C8051F120
1398   3               SFRPAGE = UART0_PAGE;
1399   3      #endif
1400   3      
1401   3               RS485_ENABLE = RS485_ENABLE_ON;
1402   3               SEND_BYTE(CMD_ACK);
1403   3               SEND_BYTE(0);
1404   3               DELAY_US(10);
1405   3               RS485_ENABLE = RS485_ENABLE_OFF;
1406   3      
1407   3            } else if (cmd == UCMD_VERIFY) {
1408   3      
1409   3               /* receive page */
1410   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1411   3                  DELAY_US(10);
1412   3               if (!RI0) 
1413   3                  goto receive_cmd;
1414   3      
1415   3               page = SBUF0;
1416   3               RI0 = 0;
1417   3      
1418   3               pr = 512 * page;
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 24  

1419   3      
1420   3               /* return simplified CRC */
1421   3               for (i = crc = 0; i < 512; i++)
1422   3                  crc += *pr++;
1423   3      
1424   3               /* return acknowledge */
1425   3               RS485_ENABLE = RS485_ENABLE_ON;
1426   3               SEND_BYTE(CMD_ACK);
1427   3               SEND_BYTE(crc);
1428   3               DELAY_US(10);
1429   3               RS485_ENABLE = RS485_ENABLE_OFF;
1430   3      
1431   3            } else if (cmd == UCMD_READ) {
1432   3      
1433   3               /* receive page */
1434   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1435   3                  DELAY_US(10);
1436   3               if (!RI0) 
1437   3                  goto receive_cmd;
1438   3               page = SBUF0;
1439   3               RI0 = 0;
1440   3      
1441   3               /* receive subpage */
1442   3               for (i=0 ; !RI0 && i < 5000 ; i++)
1443   3                  DELAY_US(10);
1444   3               if (!RI0) 
1445   3                  goto receive_cmd;
1446   3               j = SBUF0;
1447   3               RI0 = 0;
1448   3      
1449   3               RS485_ENABLE = RS485_ENABLE_ON;
1450   3      
1451   3               SEND_BYTE(CMD_ACK+7);     // send acknowledge, variable data length
1452   3               SEND_BYTE(32);            // send data length
1453   3      
1454   3               pr = (512 * page + 32 * j);
1455   3      
1456   3               /* send 32 bytes */
1457   3               for (k = crc = 0 ; k<32 ; k++) {
1458   4                  SEND_BYTE(*pr);
1459   4                  crc += *pr++;
1460   4               }
1461   3      
1462   3               SEND_BYTE(crc);
1463   3               DELAY_US(10);
1464   3               RS485_ENABLE = RS485_ENABLE_OFF;
1465   3      
1466   3            } else if (cmd == UCMD_REBOOT) {
1467   3      
1468   3      #ifdef CPU_C8051F120
1469   3               SFRPAGE = LEGACY_PAGE;
1470   3      #endif
1471   3               RSTSRC = 0x10;
1472   3            }
1473   2      
1474   2         } while (cmd != UCMD_RETURN);
1475   1      
1476   1      
1477   1         _flkey = 0;
1478   1         EA = 1;                      // re-enable interrupts
1479   1      }
1480          
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 25  

1481          /* block remainder of segment for linker */
1482          // unsigned char code BLOCK_F000_REMAINDER[0x9F2] _at_ 0xF60D; // for small model
1483          unsigned char code BLOCK_F000_REMAINDER[0x7AC] _at_ 0xF853; // for large model
1484          
1485          /*------------------------------------------------------------------*\
1486          
1487            Yield should be called periodically by applications with long loops
1488            to insure proper watchdog refresh and other functions
1489          
1490          \*------------------------------------------------------------------*/
1491          
1492          #ifdef CFG_HAVE_RTC
              unsigned long xdata rtc_last;   
              #endif
1495          
1496          void yield(void)
1497          {
1498   1         watchdog_refresh(0);
1499   1      
1500   1         /* output RS232 data if present */
1501   1      #ifdef CFG_UART1_DEVICE
1502   1         rs232_output();
1503   1      #endif
1504   1      
1505   1         /* blink LED if not configured */
1506   1         if (!configured_addr)
1507   1            led_blink(0, 1, 50);
1508   1      
1509   1         /* blink LED if wrong CPU */
1510   1         if (wrong_cpu)
1511   1            led_blink(0, 1, 30);
1512   1      
1513   1         /* flash EEPROM if asked by interrupt routine, wait 3 sec
1514   1            after reboot (power might not be stable) */
1515   1         if (flash_param && flash_allowed) {
1516   2            led_blink(_cur_sub_addr, 1, 50);
1517   2      
1518   2            flash_param = 0;
1519   2      
1520   2            eeprom_flash(); 
1521   2            configured_addr = 1;
1522   2         }
1523   1      
1524   1         /* flash EEPROM if variables just got initialized */
1525   1         if (!configured_vars && flash_allowed) {
1526   2            _flkey = 0xF1;
1527   2            eeprom_flash();
1528   2            configured_vars = 1;
1529   2         }
1530   1      
1531   1         if (flash_program && flash_allowed) {
1532   2            flash_program = 0;
1533   2      
1534   2      #ifdef CFG_HAVE_LCD
                    lcd_clear();
                    lcd_goto(0, 0);
                    puts("    Upgrading"); 
                    lcd_goto(0, 1);
                    puts("    Firmware...");
              #endif
1541   2      
1542   2            /* go to "bootloader" program */
C51 COMPILER V9.01   MSCBMAIN                                                              11/15/2013 10:23:25 PAGE 26  

1543   2            upgrade();
1544   2         }
1545   1      
1546   1      #ifdef CFG_HAVE_RTC
                 if (rtc_set) {
                    rtc_write(rtc_bwrite);
                    rtc_set = 0;
                 }
              
                 if (time() > rtc_last+90 || time() < rtc_last) {
                    rtc_last = time();
                    rtc_read(rtc_bread);
                 }
              #endif
1557   1      
1558   1         /* allow flash 3 sec after reboot */
1559   1         if (!flash_allowed && time() > 300)
1560   1            flash_allowed = 1;
1561   1      
1562   1      }
1563          
1564          /*------------------------------------------------------------------*\
1565          
1566            Main loop
1567          
1568          \*------------------------------------------------------------------*/
1569          
1570          void main(void)
1571          {
1572   1         setup();
1573   1      
1574   1         do {
1575   2            yield();
1576   2            
1577   2      #ifdef CFG_UART1_MSCB
                    manage_remote_vars();
              #endif
1580   2            
1581   2            user_loop();
1582   2      
1583   2         } while (1);
1584   1      
1585   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6098    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =    320    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      32
   IDATA SIZE       =     32      15
   BIT SIZE         =      7    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
