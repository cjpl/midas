C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MSCBUTIL
OBJECT MODULE PLACED IN .\mscbutil.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\src\mscbutil.c OPTIMIZE(4,SPEED) BROWSE INCDIR(\midas\mscb\embedded\incl
                    -ude) DEBUG OBJECTEXTEND PRINT(.\mscbutil.lst) TABS(3) OBJECT(.\mscbutil.obj)

line level    source

   1          /********************************************************************\
   2          
   3            Name:         mscbutil.c
   4            Created by:   Stefan Ritt
   5          
   6            Contents:     Various utility functions for MSCB protocol
   7          
   8            $Id$
   9          
  10          \********************************************************************/
  11          
  12          #include <intrins.h>
  13          #include <string.h>
  14          #include <stdio.h>
  15          #include "mscbemb.h"
  16          
  17          #ifdef CFG_HAVE_LCD
              #include "lcd.h"
              #endif
  20          
  21          #ifdef RS485_SEC_EN_PIN
              sbit RS485_SEC_ENABLE = RS485_SEC_EN_PIN; // port pin for secondary RS485 enable
              #endif
  24          
  25          #ifdef EXT_WATCHDOG_PIN
              sbit EXT_WATCHDOG = EXT_WATCHDOG_PIN;     // port pin for external watchdog
              #endif
  28          
  29          #ifdef CFG_HAVE_EEPROM
  30          
  31          extern SYS_INFO idata sys_info;           // for eeprom functions
  32          extern MSCB_INFO_VAR *variables;
  33          
  34          #endif
  35          
  36          extern unsigned char idata _n_sub_addr, _var_size, _flkey;
  37          
  38          #pragma NOAREGS    // all functions can be called from interrupt routine!
  39          
  40          /*------------------------------------------------------------------*/
  41          
  42          union _f_ul {
  43            float f;
  44            unsigned long ul;
  45          };
  46          
  47          float nan(void)
  48          {
  49   1        union _f_ul x;
  50   1      
  51   1        x.ul = 0xFFFFFFFF;
  52   1        return x.f;
  53   1      }
  54          
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 2   

  55          /*------------------------------------------------------------------*/
  56          
  57          unsigned char code crc8_data[] = {
  58             0x00, 0x5e, 0xbc, 0xe2, 0x61, 0x3f, 0xdd, 0x83,
  59             0xc2, 0x9c, 0x7e, 0x20, 0xa3, 0xfd, 0x1f, 0x41,
  60             0x9d, 0xc3, 0x21, 0x7f, 0xfc, 0xa2, 0x40, 0x1e,
  61             0x5f, 0x01, 0xe3, 0xbd, 0x3e, 0x60, 0x82, 0xdc,
  62             0x23, 0x7d, 0x9f, 0xc1, 0x42, 0x1c, 0xfe, 0xa0,
  63             0xe1, 0xbf, 0x5d, 0x03, 0x80, 0xde, 0x3c, 0x62,
  64             0xbe, 0xe0, 0x02, 0x5c, 0xdf, 0x81, 0x63, 0x3d,
  65             0x7c, 0x22, 0xc0, 0x9e, 0x1d, 0x43, 0xa1, 0xff,
  66             0x46, 0x18, 0xfa, 0xa4, 0x27, 0x79, 0x9b, 0xc5,
  67             0x84, 0xda, 0x38, 0x66, 0xe5, 0xbb, 0x59, 0x07,
  68             0xdb, 0x85, 0x67, 0x39, 0xba, 0xe4, 0x06, 0x58,
  69             0x19, 0x47, 0xa5, 0xfb, 0x78, 0x26, 0xc4, 0x9a,
  70             0x65, 0x3b, 0xd9, 0x87, 0x04, 0x5a, 0xb8, 0xe6,
  71             0xa7, 0xf9, 0x1b, 0x45, 0xc6, 0x98, 0x7a, 0x24,
  72             0xf8, 0xa6, 0x44, 0x1a, 0x99, 0xc7, 0x25, 0x7b,
  73             0x3a, 0x64, 0x86, 0xd8, 0x5b, 0x05, 0xe7, 0xb9,
  74             0x8c, 0xd2, 0x30, 0x6e, 0xed, 0xb3, 0x51, 0x0f,
  75             0x4e, 0x10, 0xf2, 0xac, 0x2f, 0x71, 0x93, 0xcd,
  76             0x11, 0x4f, 0xad, 0xf3, 0x70, 0x2e, 0xcc, 0x92,
  77             0xd3, 0x8d, 0x6f, 0x31, 0xb2, 0xec, 0x0e, 0x50,
  78             0xaf, 0xf1, 0x13, 0x4d, 0xce, 0x90, 0x72, 0x2c,
  79             0x6d, 0x33, 0xd1, 0x8f, 0x0c, 0x52, 0xb0, 0xee,
  80             0x32, 0x6c, 0x8e, 0xd0, 0x53, 0x0d, 0xef, 0xb1,
  81             0xf0, 0xae, 0x4c, 0x12, 0x91, 0xcf, 0x2d, 0x73,
  82             0xca, 0x94, 0x76, 0x28, 0xab, 0xf5, 0x17, 0x49,
  83             0x08, 0x56, 0xb4, 0xea, 0x69, 0x37, 0xd5, 0x8b,
  84             0x57, 0x09, 0xeb, 0xb5, 0x36, 0x68, 0x8a, 0xd4,
  85             0x95, 0xcb, 0x29, 0x77, 0xf4, 0xaa, 0x48, 0x16,
  86             0xe9, 0xb7, 0x55, 0x0b, 0x88, 0xd6, 0x34, 0x6a,
  87             0x2b, 0x75, 0x97, 0xc9, 0x4a, 0x14, 0xf6, 0xa8,
  88             0x74, 0x2a, 0xc8, 0x96, 0x15, 0x4b, 0xa9, 0xf7,
  89             0xb6, 0xe8, 0x0a, 0x54, 0xd7, 0x89, 0x6b, 0x35,
  90          };
  91          
  92          unsigned char crc8(unsigned char *buffer, int len) reentrant
  93          /********************************************************************\
  94          
  95            Routine: crc8
  96          
  97            Purpose: Calculate 8-bit cyclic redundancy checksum for a full
  98                     buffer
  99          
 100            Input:
 101              unsigned char *data     data buffer
 102              int len                 data length in bytes
 103          
 104          
 105            Function value:
 106              unsighend char          CRC-8 code
 107          
 108          \********************************************************************/
 109          {
 110   1         int i;
 111   1         unsigned char crc8_code, index;
 112   1      
 113   1         crc8_code = 0;
 114   1         for (i = 0; i < len; i++) {
 115   2            index = buffer[i] ^ crc8_code;
 116   2            crc8_code = crc8_data[index];
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 3   

 117   2         }
 118   1      
 119   1         return crc8_code;
 120   1      }
 121          
 122          unsigned char crc8_add(unsigned char crc, unsigned int c)
 123          /********************************************************************\
 124          
 125            Routine: crc8_add
 126          
 127            Purpose: Single calculation for 8-bit cyclic redundancy checksum
 128          
 129            Input:
 130              unsigned char crc       running crc
 131              unsigned char c         new character
 132          
 133          
 134            Function value:
 135              unsighend char          CRC-8 code
 136          
 137          \********************************************************************/
 138          {
 139   1         unsigned char idata index;
 140   1      
 141   1         index = c ^ crc;
 142   1         return crc8_data[index];
 143   1      }
 144          
 145          /*------------------------------------------------------------------*/
 146          
 147          //####################################################################
 148          #if defined(CFG_UART1_DEVICE) // user-level device communication via UART1
 149          
 150          bit ti1_shadow = 1;
 151          
 152          char xdata rbuf[2048];
 153          char xdata sbuf[1024];
 154          
 155          unsigned char xdata * xdata rbuf_rp = rbuf;
 156          unsigned char xdata * xdata rbuf_wp = rbuf;
 157          unsigned char xdata * xdata sbuf_rp = sbuf;
 158          unsigned char xdata * xdata sbuf_wp = sbuf;
 159          
 160          /*---- UART1 handling ----------------------------------------------*/
 161          
 162          void serial_int1(void) interrupt 20
 163          {
 164   1         if (SCON1 & 0x02) {          // TI1
 165   2      
 166   2      #ifdef RS485_SEC_EN_PIN
                    if (sbuf_wp == sbuf_rp)
                       RS485_SEC_ENABLE = 0;
              #endif
 170   2      
 171   2            /* character has been transferred */
 172   2            SCON1 &= ~0x02;           // clear TI flag
 173   2            ti1_shadow = 1;
 174   2         }
 175   1      
 176   1         if (SCON1 & 0x01) {          // RI1
 177   2            /* check for buffer overflow */
 178   2            if (rbuf_wp + 1 == rbuf_rp) {
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 4   

 179   3               SCON1 &= ~0x01;        // clear RI flag
 180   3               return;
 181   3            }
 182   2      
 183   2            /* character has been received */
 184   2            *rbuf_wp++ = SBUF1;
 185   2            if (rbuf_wp == rbuf + sizeof(rbuf))
 186   2               rbuf_wp = rbuf;
 187   2      
 188   2            SCON1 &= ~0x01;           // clear RI flag
 189   2      
 190   2      #ifdef UART1_BLINK
                    led_blink(1, 1, 100);
              #endif
 193   2         }
 194   1      }
 195          
 196          /*------------------------------------------------------------------*/
 197          
 198          void rs232_output(void)
 199          /* check RS232 output buffer to send data */
 200          {
 201   1         if (sbuf_wp != sbuf_rp && ti1_shadow == 1) {
 202   2            ti1_shadow = 0;
 203   2      #ifdef RS485_SEC_EN_PIN
                    RS485_SEC_ENABLE = 1;
              #endif
 206   2      
 207   2      #ifdef CPU_C8051F120
 208   2            SFRPAGE = UART1_PAGE;
 209   2      #endif
 210   2      
 211   2            SBUF1 = *sbuf_rp++;
 212   2            if (sbuf_rp == sbuf + sizeof(sbuf))
 213   2               sbuf_rp = sbuf;
 214   2         }
 215   1      }
 216          
 217          /*------------------------------------------------------------------*/
 218          
 219          char getchar(void)
 220          {
 221   1         char idata c;
 222   1      
 223   1         do {
 224   2            if (rbuf_wp != rbuf_rp) {
 225   3               c = *rbuf_rp++;
 226   3               if (rbuf_rp == rbuf + sizeof(rbuf))
 227   3                  rbuf_rp = rbuf;
 228   3      
 229   3               if (c == '\r')         /* make gets() happy */
 230   3                  return '\n';
 231   3      
 232   3               return c;
 233   3            }
 234   2            yield();
 235   2         } while (1);
 236   1      }
 237          
 238          /*------------------------------------------------------------------*/
 239          
 240          char getchar_nowait(void) reentrant
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 5   

 241          {
 242   1         char c;
 243   1      
 244   1         if (rbuf_wp != rbuf_rp) {
 245   2            c = *rbuf_rp++;
 246   2            if (rbuf_rp == rbuf + sizeof(rbuf))
 247   2               rbuf_rp = rbuf;
 248   2      
 249   2            return c;
 250   2         }
 251   1         return -1;
 252   1      }
 253          
 254          /*------------------------------------------------------------------*/
 255          
 256          unsigned char gets_wait(char *str, unsigned char size, unsigned char timeout)
 257          {
 258   1         unsigned long idata start;
 259   1         unsigned char idata i;
 260   1         char c;
 261   1      
 262   1         start = time();
 263   1         i = 0;
 264   1         do {
 265   2            c = getchar_nowait();
 266   2            if (c != -1 && c != '\n') {
 267   3               if (c == '\r') {
 268   4                  str[i] = 0;
 269   4                  return i;
 270   4               }
 271   3               str[i++] = c;
 272   3               if (i == size)
 273   3                  return i;
 274   3            }
 275   2      
 276   2            yield();
 277   2         } while (time() < start + timeout);
 278   1      
 279   1         return 0;
 280   1      }
 281          
 282          /*------------------------------------------------------------------*/
 283          
 284          #ifdef CFG_HAVE_LCD // putchar is already used for LCD
              
              char putchar1(char c)
              {
                 /* check if buffer overflow */
                 if (sbuf_wp + 1 == sbuf_rp)
                    return c;
              
                 *sbuf_wp++ = c;
                 if (sbuf_wp == sbuf + sizeof(sbuf))
                    sbuf_wp = sbuf;
              
                 return c;
              }
              
              #else // CFG_HAVE_LCD
 300          
 301          char putchar(char c)
 302          {
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 6   

 303   1         /* check if buffer overflow */
 304   1         if (sbuf_wp + 1 == sbuf_rp)
 305   1            return c;
 306   1      
 307   1         *sbuf_wp++ = c;
 308   1         if (sbuf_wp == sbuf + sizeof(sbuf))
 309   1            sbuf_wp = sbuf;
 310   1      
 311   1         return c;
 312   1      }
 313          
 314          #endif // CFG_HAVE_LCD
 315          
 316          /*------------------------------------------------------------------*/
 317          
 318          void flush(void)
 319          {
 320   1         while (sbuf_wp != sbuf_rp) {
 321   2            watchdog_refresh(0);
 322   2            rs232_output();
 323   2         }
 324   1      }
 325          
 326          /*------------------------------------------------------------------*/
 327          
 328          void uart1_init_buffer()
 329          {
 330   1         rbuf_rp = rbuf_wp = rbuf;
 331   1         sbuf_rp = sbuf_wp = sbuf;
 332   1         memset(rbuf, 0, sizeof(rbuf));
 333   1         memset(sbuf, 0, sizeof(sbuf));
 334   1      
 335   1         ti1_shadow = 1;
 336   1      }
 337          
 338          /*------------------------------------------------------------------*/
 339          
 340          #endif // CFG_UART1_DEVICE ###########################################
 341          
 342          #if defined(CFG_UART1_MSCB) // UART1 connected as master to MSCB slave bus
              
              bit ti1_shadow = 1;
              unsigned char idata n_recv;
              
              char xdata rbuf[64];
              
              /*---- UART1 handling ----------------------------------------------*/
              
              void serial_int1(void) interrupt 20 
              {
                 if (SCON1 & 0x02) {          // TI1
                    /* character has been transferred */
                    SCON1 &= ~0x02;           // clear TI flag
                    ti1_shadow = 1;
                 }
              
                 if (SCON1 & 0x01) {          // RI1
                    /* check for buffer overflow */
                    if (n_recv + 1 == sizeof(rbuf)) {
                       SCON1 &= ~0x01;        // clear RI flag
                       return;
                    }
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 7   

              
                    /* character has been received */
                    rbuf[n_recv++] = SBUF1;
                    SCON1 &= ~0x01;           // clear RI flag
                 }
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned char uart1_send(char *buffer, int size, unsigned char bit9)
              {
              unsigned char idata i;
              
                 /* empty receive buffer */
                 n_recv = 0;
              
                 SFRPAGE = UART1_PAGE;
              
                 RS485_SEC_ENABLE = 1;
                 TB81 = bit9;
              
                 for (i=0 ; i<size ; i++) {
              
                    ti1_shadow = 0;
              
                    DELAY_US(INTERCHAR_DELAY);
              
                    if (i == size-1) {
                      
                       /* interrupt between last send and enable=0 could cause bus collision */
                       ES0 = 0;
              
                       SBUF1 = *buffer++;
                       while (ti1_shadow == 0);
                       
                       RS485_SEC_ENABLE = 0;
              
                       ES0 = 1;
              
                    } else {
              
                       SBUF1 = *buffer++;
                       while (ti1_shadow == 0);
              
                    }
              
                    watchdog_refresh(1);
                 }
                 RS485_SEC_ENABLE = 0;
              
                 return size;
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned char uart1_receive(char *buffer, int size)
              {
              unsigned char idata len;
              long idata start_time;
              
                 start_time = time();
                 len = 0;
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 8   

                 do {
              
                    if (time() - start_time > 1) // timeout after 20ms
                       return 0;
              
                    if (n_recv > 0) {
              
                       /* response to ping */
                       if (rbuf[0] == CMD_ACK)
                          return 1;
              
                       /* response to CMD_READ */
                       if ((rbuf[0] & 0xF8) != CMD_ACK)
                          return 0;
              
                       len = (rbuf[0] & 0x07) + 2;
              
                       if (n_recv == len) {
                          if (n_recv > size)
                             memcpy(buffer, rbuf, size);
                          else
                             memcpy(buffer, rbuf, n_recv);
                          return len;
                       }
                    }
              
                    watchdog_refresh(1);
              
                 } while (1);
              
                 return len;
              }
              
              /*------------------------------------------------------------------*/
              
              void uart1_init_buffer()
              {
                 n_recv = 0;
                 ti1_shadow = 1;
              }
              
              /*------------------------------------------------------------------*/
              
              #endif // CFG_UART1_MSCB ##############################################
 471          
 472          /*------------------------------------------------------------------*/
 473          
 474          void uart_init(unsigned char port, unsigned char baud)
 475          /********************************************************************\
 476          
 477            Routine: uart_init
 478          
 479            Purpose: Initialize serial interface, user Timer 1 for UART0 and
 480                     (optionally) Timer 2 (4 for F020) for UART1
 481          
 482            Input:
 483              unsigned char baud
 484                1:    2400
 485                2:    4800
 486                3:    9600
 487                4:   19200
 488                5:   28800
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 9   

 489                6:   38400
 490                7:   57600
 491                8:  115200
 492                9:  172800
 493               10:  345600
 494          
 495          \********************************************************************/
 496          {
 497   1      #if defined (CPU_C8051F310)           // 24.5 MHz
                 unsigned char code baud_table[] =
                   {0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 213,  //  57600
                    0x100 - 106,  // 115200
                    0x100 - 71,   // 172800
                    0x100 - 35 }; // 345600
              #elif defined(CPU_C8051F320)          // 12 MHz
                 unsigned char code baud_table[] =
                   {0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 208,  //  28800
                    0x100 - 156,  //  38400
                    0x100 - 104,  //  57600
                    0x100 - 52,   // 115200
                    0x100 - 35,   // 172800  2% error
                    0x100 - 17 }; // 345600  2% error
              #elif defined(CLK_25MHZ)              // 24.5 MHz
 522   1         unsigned char code baud_table[] =  // UART0 via timer 2
 523   1           {0x100 - 0,    //  N/A
 524   1            0x100 - 0,    //  N/A
 525   1            0x100 - 160,  //   9600  0.3% error
 526   1            0x100 - 80,   //  19200  0.3% error
 527   1            0x100 - 53,   //  28800  0.3% error
 528   1            0x100 - 40,   //  38400  0.3% error
 529   1            0x100 - 27,   //  57600  1.5% error
 530   1            0x100 - 13,   // 115200  2.2% error
 531   1            0x100 - 9,    // 172800  1.5% error
 532   1            0x100 - 0 };  // N/A
 533   1         #if defined(CFG_UART1_DEVICE) || defined(CFG_UART1_MSCB)
 534   1         unsigned char code baud_table1[] = // UART1 via timer 1
 535   1           {0x100 - 106,  //   2400  0.3% error
 536   1            0x100 - 53,   //   4800  0.3% error
 537   1            0x100 - 27,   //   9600  1.5% error
 538   1            0x100 - 13,   //  19200  2.2% error
 539   1            0x100 - 9,    //  28800  1.5% error
 540   1            0x100 - 7,    //  38400  5.1% error
 541   1            0x100 - 0,    //  N/A
 542   1            0x100 - 0,    //  N/A
 543   1            0x100 - 0,    //  N/A
 544   1            0x100 - 0};   //  N/A
 545   1         #endif
 546   1      #elif defined(CLK_49MHZ)              // 49 MHz
                 unsigned char code baud_table[] =  // UART0 via timer 2
                   {0xFB, 0x100 - 252,  //   2400
                    0xFD, 0x100 - 126,  //   4800
                    0xFE, 0x100 - 63,   //   9600
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 10  

                    0xFF, 0x100 - 160,  //  19200  0.3% error
                    0xFF, 0x100 - 106,  //  28800  0.3% error
                    0xFF, 0x100 - 80,   //  38400  0.3% error
                    0xFF, 0x100 - 53,   //  57600  0.3% error
                    0xFF, 0x100 - 27,   // 115200  1.5% error
                    0xFF, 0x100 - 18,   // 172800  1.5% error
                    0xFF, 0x100 - 9 };  // 345600  1.5% error
              #elif defined(CLK_98MHZ)          // 98 MHz
                 unsigned char code baud_table[] =  // UART0 via timer 2
                   {0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 0,    //  N/A
                    0x100 - 213,  //  28800  0.2% error
                    0x100 - 160,  //  38400  0.3% error
                    0x100 - 106,  //  57600  0.3% error
                    0x100 - 53,   // 115200  0.3% error
                    0x100 - 35,   // 172800  1.3% error
                    0x100 - 18 }; // 345600  1.6% error
              #if defined(CFG_UART1_MSCB) || defined(CFG_UART1_DEVICE)
                 unsigned char code baud_table1[] = // UART1 via timer 1
                   {0x100 - 0,    //  N/A
                    0x100 - 212,  //   4800  0.3% error
                    0x100 - 106,  //   9600  0.3% error
                    0x100 - 53,   //  19200  0.3% error
                    0x100 - 35,   //  28800  1.3% error
                    0x100 - 27,   //  38400  1.6% error
                    0x100 - 18,   //  57600  1.6% error
                    0x100 - 9,    // 115200  1.6% error
                    0x100 - 6,    // 172800  1.6% error
                    0x100 - 3 };  // 345600  1.6% error
              #endif
              #else                                 // 11.0592 MHz
                 unsigned char code baud_table[] =
                   {0x100 - 144,  //   2400
                    0x100 - 72,   //   4800
                    0x100 - 36,   //   9600
                    0x100 - 18,   //  19200
                    0x100 - 12,   //  28800
                    0x100 - 9,    //  38400
                    0x100 - 6,    //  57600
                    0x100 - 3,    // 115200
                    0x100 - 2,    // 172800
                    0x100 - 1 };  // 345600
              #endif
 596   1      
 597   1         if (port == 0) { /*---- UART0 ----*/
 598   2      
 599   2      #ifdef CPU_C8051F120
 600   2            SFRPAGE = UART0_PAGE;
 601   2      #endif
 602   2      
 603   2            SCON0 = 0xD0;                // Mode 3, 9 bit, receive enable
 604   2      
 605   2      #ifdef CPU_C8051F120
 606   2      
 607   2            SFRPAGE = UART0_PAGE;
 608   2            SSTA0 = 0x15;                // User Timer 2 for baud rate, div2 disabled
 609   2      
 610   2            SFRPAGE = TMR2_PAGE;
 611   2            TMR2CF = 0x08;               // use system clock for timer 2
 612   2      #ifdef CLK_49MHZ
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 11  

                    RCAP2H = baud_table[(baud - 1)*2];    // load high byte
                    RCAP2L = baud_table[(baud - 1)*2+1];  // load low byte
              #else
 616   2            RCAP2H = 0xFF;
 617   2            RCAP2L = baud_table[baud - 1];
 618   2      #endif
 619   2            TMR2CN = 0x04;               // start timer 2
 620   2            SFRPAGE = UART0_PAGE;
 621   2      
 622   2      #else // CPU_C8051F120
              
                    TMOD  = (TMOD & 0x0F)| 0x20; // Timer 1 8-bit counter with auto reload
              
              #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                    CKCON |= 0x08;               // use system clock
              #else
                    T2CON &= ~30;                // User Timer 1 for baud rate
                    CKCON |= 0x10;               // use system clock
              #endif
              
                    TH1 = baud_table[baud - 1];  // load initial values
                    TR1 = 1;                     // start timer 1
              
              #endif // CPU_C8051F120
 637   2      
 638   2            ES0 = 1;                     // enable serial interrupt
 639   2            PS0 = 0;                     // serial interrupt low priority
 640   2      
 641   2      
 642   2      #if defined(CFG_UART1_MSCB) || defined(CFG_UART1_DEVICE)
 643   2      
 644   2         } else { /*---- UART1 ----*/
 645   2      
 646   2      #if defined(CPU_C8051F020)
                    SCON1 = 0x50;                // Mode 1, 8 bit, receive enable
              
                    T4CON = 0x34;                // timer 4 RX+TX mode
                    RCAP4H = 0xFF;
                    RCAP4L = baud_table[baud - 1];
              
                    EIE2 |= 0x40;                // enable serial interrupt
                    EIP2 &= ~0x40;               // serial interrupt low priority
              
              
              #elif defined(CLK_25MHZ)           // 24.5 MHz
 658   2            SFRPAGE = UART1_PAGE;
 659   2            SCON1 = 0x50;                // Mode 1, 8 bit, receive enable
 660   2      
 661   2            SFRPAGE = TIMER01_PAGE;
 662   2            TMOD  = (TMOD & 0x0F)| 0x20; // Timer 1 8-bit counter with auto reload
 663   2            CKCON = 0x02;                // use SYSCLK/48 (needed by timer 0)
 664   2      
 665   2            TH1 = baud_table1[baud - 1];
 666   2            TR1 = 1;                     // start timer 1
 667   2      
 668   2            EIE2 |= 0x40;                // enable serial interrupt
 669   2            EIP2 &= ~0x40;               // serial interrupt low priority
 670   2      #elif defined(CLK_98MHZ)           // 98 MHz
                    SFRPAGE = UART1_PAGE;
              #ifdef CFG_UART1_MSCB
                    SCON1 = 0xD0;                // Mode 3, 9 bit, receive enable
              #else
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 12  

                    SCON1 = 0x50;                // Mode 1, 8 bit, receive enable
              #endif
              
                    SFRPAGE = TIMER01_PAGE;
                    TMOD  = (TMOD & 0x0F)| 0x20; // Timer 1 8-bit counter with auto reload
                    CKCON = 0x02;                // use SYSCLK/48 (needed by timer 0)
              
                    TH1 = baud_table1[baud - 1];
                    TR1 = 1;                     // start timer 1
              
                    EIE2 |= 0x40;                // enable serial interrupt
                    EIP2 |= 0x40;                // serial interrupt high priority, needed in order not
                                                 // to loose data during UART0 communication
              #endif
 689   2      
 690   2            uart1_init_buffer();
 691   2      #endif // defined(CFG_UART1_MSCB) || defined(CFG_UART1_DEVICE)
 692   2         }
 693   1      
 694   1         EA = 1;                         // general interrupt enable
 695   1      }
 696          
 697          /*------------------------------------------------------------------*/
 698          
 699          #ifdef CPU_C8051F120
 700          
 701          static unsigned long xdata _systime;
 702          static unsigned long xdata _uptime;
 703          static unsigned char xdata _uptime_cnt;
 704          
 705          /* LED structure */
 706          struct {
 707            unsigned char mode;
 708            unsigned char timer;
 709            unsigned char interval;
 710            unsigned char n;
 711          } xdata leds[N_LED];
 712          
 713          #else
              
              static unsigned long idata _systime;
              static unsigned long idata _uptime;
              static unsigned char idata _uptime_cnt;
              
              /* LED structure */
              struct {
                unsigned char mode;
                unsigned char timer;
                unsigned char interval;
                unsigned char n;
              } idata leds[N_LED];
              
              #endif
 728          
 729          #ifdef LED_0
 730          sbit led_0 = LED_0;
 731          #endif
 732          #ifdef LED_1
 733          sbit led_1 = LED_1;
 734          #endif
 735          #ifdef LED_2
              sbit led_2 = LED_2;
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 13  

              #endif
 738          #ifdef LED_3
              sbit led_3 = LED_3;
              #endif
 741          #ifdef LED_4
              sbit led_4 = LED_4;
              #endif
 744          #ifdef LED_5
              sbit led_5 = LED_5;
              #endif
 747          #ifdef LED_6
              sbit led_6 = LED_6;
              #endif
 750          #ifdef LED_7
              sbit led_7 = LED_7;
              #endif
 753          #ifdef LED_8
              sbit led_8 = LED_8;
              #endif
 756          #ifdef LED_9
              sbit led_9 = LED_9;
              #endif
 759          #ifdef LED_10
              sbit led_10 = LED_10;
              #endif
 762          #ifdef LED_11
              sbit led_11 = LED_11;
              #endif
 765          #ifdef LED_12
              sbit led_12 = LED_12;
              #endif
 768          #ifdef LED_13
              sbit led_13 = LED_13;
              #endif
 771          #ifdef LED_14
              sbit led_14 = LED_14;
              #endif
 774          #ifdef LED_15
              sbit led_15 = LED_15;
              #endif
 777          
 778          /*------------------------------------------------------------------*/
 779          
 780          void sysclock_reset(void)
 781          /********************************************************************\
 782          
 783            Routine: sysclock_reset
 784          
 785            Purpose: Reset system clock and uptime counter
 786          
 787          *********************************************************************/
 788          {
 789   1         unsigned char idata i;
 790   1      
 791   1         _systime = 0;
 792   1         _uptime = 0;
 793   1         _uptime_cnt = 100;
 794   1      
 795   1         for (i=0 ; i<N_LED ; i++) {
 796   2           leds[i].mode = 0;
 797   2           leds[i].timer = 0;
 798   2           leds[i].interval = 0;
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 14  

 799   2           leds[i].n = 0;
 800   2         }
 801   1      }
 802          
 803          /*------------------------------------------------------------------*/
 804          
 805          
 806          void sysclock_init(void)
 807          /********************************************************************\
 808          
 809            Routine: sysclock_init
 810          
 811            Purpose: Initial sytem clock via timer 0
 812          
 813          *********************************************************************/
 814          {
 815   1         EA = 1;                      // general interrupt enable
 816   1         ET0 = 1;                     // Enable Timer 0 interrupt
 817   1         PT1 = 0;                     // Interrupt priority low
 818   1      
 819   1      #ifdef CPU_C8051F120
 820   1         SFRPAGE = TIMER01_PAGE;
 821   1      #endif
 822   1      
 823   1         TMOD = (TMOD & 0x0F) | 0x01; // 16-bit counter
 824   1      #if defined(CLK_25MHZ)
 825   1         CKCON = 0x02;                // use SYSCLK/48
 826   1         TH0 = 0xEC;                  // load initial value (24.5 MHz SYSCLK)
 827   1      #elif defined(CPU_C8051F120)
                 CKCON = 0x02;                // use SYSCLK/48 (98 MHz SYSCLK)
                 TH0 = 0xAF;                  // load initial value
              #elif defined(CPU_C8051F310)
                 CKCON = 0x00;                // use SYSCLK/12
                 TH0 = 0xAF;                  // load initial value (24.5 MHz SYSCLK)
              #else
                 CKCON = 0x00;                // use SYSCLK/12
                 TH0 = 0xDB;                  // load initial value
              #endif
 837   1      
 838   1         TL0 = 0x00;
 839   1         TR0 = 1;                     // start timer 0
 840   1      
 841   1         sysclock_reset();
 842   1      }
 843          
 844          /*------------------------------------------------------------------*/
 845          
 846          void led_int() reentrant
 847          {
 848   1      unsigned char led_i;
 849   1      
 850   1         /* manage blinking LEDs */
 851   1         for (led_i=0 ; led_i<N_LED ; led_i++) {
 852   2            if (leds[led_i].n > 0 && leds[led_i].timer == 0) {
 853   3               if ((leds[led_i].n & 1) && leds[led_i].n > 1)
 854   3                  led_set(led_i, LED_ON);
 855   3               else
 856   3                  led_set(led_i, LED_OFF);
 857   3      
 858   3               if (leds[led_i].n == 1)
 859   3                  led_set(led_i, LED_OFF);
 860   3      
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 15  

 861   3               leds[led_i].n--;
 862   3               if (leds[led_i].n)
 863   3                  leds[led_i].timer = leds[led_i].interval;
 864   3            }
 865   2      
 866   2            if (leds[led_i].timer)
 867   2               leds[led_i].timer--;
 868   2         }
 869   1      }
 870          
 871          /*------------------------------------------------------------------*/
 872          
 873          extern void tcp_timer(void);
 874          void watchdog_int(void) reentrant;
 875          
 876          void timer0_int(void) interrupt 1
 877          /********************************************************************\
 878          
 879            Routine: timer0_int
 880          
 881            Purpose: Timer 0 interrupt routine for 100Hz system clock
 882          
 883                     Reload value = 0x10000 - 0.01 / (11059200/12)
 884          
 885          \********************************************************************/
 886          {
 887   1      #ifdef SUBM_260
                 tcp_timer();
              #else /* SUBM_260 */
 890   1      
 891   1      #if defined(CLK_25MHZ)
 892   1         TH0 = 0xEC;                  // for 24.5 MHz clock / 48
 893   1      #elif defined(CPU_C8051F120)
                 TH0 = 0xAF;                  // for 98 MHz clock   / 48
              #elif defined(CPU_C8051F310)
                 TH0 = 0xAF;                  // for 24.5 MHz clock / 12 
              #else
                 TH0 = 0xDC;                  // reload timer values, let LSB freely run
              #endif
 900   1      
 901   1      #endif /* !SUBM_260 */
 902   1         _systime++;                  // increment system time
 903   1         _uptime_cnt--;
 904   1         if (_uptime_cnt == 0) {      // once every second
 905   2            _uptime++;
 906   2            _uptime_cnt = 100;
 907   2         }
 908   1         
 909   1         led_int();
 910   1         watchdog_int();
 911   1      }
 912          
 913          
 914          /*------------------------------------------------------------------*/
 915          
 916          void led_mode(unsigned char led, unsigned char flag) reentrant
 917          /********************************************************************\
 918          
 919            Routine: led_mode
 920          
 921            Purpose: Set LED mode
 922          
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 16  

 923            Input:
 924              int led               0 for primary, 1 for secondary
 925              int flag              Noninverted (0) / Inverted (1)
 926          
 927          \********************************************************************/
 928          {
 929   1         if (led < N_LED) {
 930   2            leds[led].mode = flag;
 931   2            led_set(led, flag);
 932   2         }
 933   1      }
 934          
 935          /*------------------------------------------------------------------*/
 936          
 937          void led_blink(unsigned char led, unsigned char n, int interval) reentrant
 938          /********************************************************************\
 939          
 940            Routine: blink led
 941          
 942            Purpose: Blink primary or secondary LED for a couple of times
 943          
 944            Input:
 945              int led               0 for primary, 1 for secondary, ...
 946              int interval          Blink interval in ms
 947              int n                 Number of blinks
 948          
 949          \********************************************************************/
 950          {
 951   1         if (led < N_LED) {
 952   2            if (leds[led].n == 0 && leds[led].timer == 0) {
 953   3               leds[led].n = n*2+1;
 954   3               leds[led].interval = interval / 10;
 955   3               leds[led].timer = 0;
 956   3            }
 957   2         }
 958   1      }
 959          
 960          /*------------------------------------------------------------------*/
 961          
 962          void led_set(unsigned char led, unsigned char flag) reentrant 
 963          {
 964   1      #ifdef CPU_C8051F120
 965   1         unsigned char old_page;
 966   1      #endif
 967   1      
 968   1         /* invert on/off if mode == 1 */
 969   1         if (led < N_LED && leds[led].mode)
 970   1            flag = !flag;
 971   1      
 972   1      #ifdef CPU_C8051F120
 973   1         old_page = SFRPAGE;
 974   1         SFRPAGE = CONFIG_PAGE;
 975   1      #endif
 976   1      
 977   1      #ifdef LED_0
 978   1         if (led == 0)
 979   1            led_0 = flag;
 980   1      #endif
 981   1      #ifdef LED_1
 982   1         else if (led == 1)
 983   1            led_1 = flag;
 984   1      #endif
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 17  

 985   1      #ifdef LED_2
                 else if (led == 2)
                    led_2 = flag;
              #endif
 989   1      #ifdef LED_3
                 else if (led == 3)
                    led_3 = flag;
              #endif
 993   1      #ifdef LED_4
                 else if (led == 4)
                    led_4 = flag;
              #endif
 997   1      #ifdef LED_5
                 else if (led == 5)
                    led_5 = flag;
              #endif
1001   1      #ifdef LED_6
                 else if (led == 6)
                    led_6 = flag;
              #endif
1005   1      #ifdef LED_7
                 else if (led == 7)
                    led_7 = flag;
              #endif
1009   1      #ifdef LED_8
                 else if (led == 8)
                    led_8 = flag;
              #endif
1013   1      #ifdef LED_9
                 else if (led == 9)
                    led_9 = flag;
              #endif
1017   1      #ifdef LED_10
                 else if (led == 10)
                    led_10 = flag;
              #endif
1021   1      #ifdef LED_11
                 else if (led == 11)
                    led_11 = flag;
              #endif
1025   1      #ifdef LED_12
                 else if (led == 12)
                    led_12 = flag;
              #endif
1029   1      #ifdef LED_13
                 else if (led == 13)
                    led_13 = flag;
              #endif
1033   1      #ifdef LED_14
                 else if (led == 14)
                    led_14 = flag;
              #endif
1037   1      #ifdef LED_15
                 else if (led == 15)
                    led_15 = flag;
              #endif
1041   1      
1042   1      #ifdef CPU_C8051F120
1043   1         SFRPAGE = old_page;
1044   1      #endif
1045   1      }
1046          
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 18  

1047          /*------------------------------------------------------------------*/
1048          
1049          unsigned long time(void)
1050          /********************************************************************\
1051          
1052            Routine: time
1053          
1054            Purpose: Return system time in units of 10ms
1055          
1056          \********************************************************************/
1057          {
1058   1         unsigned long t;
1059   1      
1060   1         DISABLE_INTERRUPTS;
1061   1         t = _systime;
1062   1         ENABLE_INTERRUPTS;
1063   1         return t;
1064   1      }
1065          
1066          /*------------------------------------------------------------------*/
1067          
1068          unsigned long uptime(void)
1069          /********************************************************************\
1070          
1071            Routine: uptime
1072          
1073            Purpose: Return system uptime in seconds
1074          
1075          \********************************************************************/
1076          {
1077   1         unsigned long t;
1078   1      
1079   1         DISABLE_INTERRUPTS;
1080   1         t = _uptime;
1081   1         ENABLE_INTERRUPTS;
1082   1         return t;
1083   1      }
1084          
1085          /*------------------------------------------------------------------*/
1086          
1087          #ifdef CFG_USE_WATCHDOG
1088          #define DEFAULT_WATCHDOG_TIMEOUT 10    // 10 seconds
1089          unsigned short idata watchdog_timer;
1090          unsigned char  idata watchdog_timeout = DEFAULT_WATCHDOG_TIMEOUT;
1091          bit                  watchdog_on;
1092          #endif
1093          
1094          void watchdog_refresh(unsigned char from_interrupt) reentrant
1095          /********************************************************************\
1096          
1097            Routine: watchdog_refresh
1098          
1099            Purpose: Resets watchdog, has to be called regularly, otherwise
1100                     the watchdog issues a reset. If called from an interrupt
1101                     routine, just reset the hardware watchdog, but not the
1102                     watchdog timer. Reset the watchdog timer only when called
1103                     from the user loop, to ensure that the main user loop
1104                     is running.
1105          
1106            Input:
1107              unsigned char from_interrupt  0 if called from normal user loop,
1108                                            1 if called from interrupt routine
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 19  

1109          
1110          
1111          \********************************************************************/
1112          {
1113   1         if (from_interrupt);
1114   1      
1115   1      #ifdef CFG_USE_WATCHDOG
1116   1         if (from_interrupt == 0)
1117   1            watchdog_timer = 0;
1118   1      
1119   1         if (watchdog_on && watchdog_timer < watchdog_timeout*100) {
1120   2      
1121   2      #ifndef CFG_EXT_WATCHDOG
1122   2      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                    PCA0CPH4 = 0x00;
              #else
1125   2            WDTCN = 0xA5;
1126   2      #endif
1127   2      #endif // !CFG_EXT_WATCHDOG
1128   2      
1129   2         }
1130   1      
1131   1      #ifdef CFG_EXT_WATCHDOG // reset external watchdog even if not on
                 if (watchdog_timer < watchdog_timeout*100) {
              #ifdef EXT_WATCHDOG_PIN_DAC1
                    unsigned char old_page;
                    old_page = SFRPAGE;
                    SFRPAGE = DAC1_PAGE;
                    DAC1CN = 0x80; // enable DAC1
                    SFRPAGE = LEGACY_PAGE;
                    REF0CN = 0x03; // enable voltage reference
                    SFRPAGE = DAC1_PAGE;
              
                    DAC1L = DAC1L > 0 ? 0 : 0xFF;
                    DAC1H = DAC1L;
                    SFRPAGE = old_page;
              #else
                    EXT_WATCHDOG = !EXT_WATCHDOG;
              #endif
                 }
              #endif // CFG_EXT_WATCHDOG
1150   1         
1151   1      
1152   1      #endif
1153   1      }
1154          
1155          /*------------------------------------------------------------------*/
1156          
1157          void watchdog_enable(unsigned char timeout)
1158          /********************************************************************\
1159          
1160            Routine: watchdog_enable
1161          
1162            Purpose: Enables watchdog
1163          
1164            Input:
1165              unsigned char timeout    Watchdog timeout in seconds
1166          
1167          \********************************************************************/
1168          {
1169   1         if (timeout);
1170   1      #ifdef CFG_USE_WATCHDOG
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 20  

1171   1      
1172   1         watchdog_on = 1;
1173   1         watchdog_timer = 0;
1174   1         if (timeout)
1175   1            watchdog_timeout = timeout;
1176   1         else
1177   1            watchdog_timeout = DEFAULT_WATCHDOG_TIMEOUT;
1178   1      
1179   1      #ifndef CFG_EXT_WATCHDOG
1180   1      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                 PCA0MD   = 0x00;             // disable watchdog
                 PCA0CPL4 = 255;              // 65.5 msec @ 12 MHz
                 PCA0MD   = 0x40;             // enable watchdog
                 PCA0CPH4 = 0x00;             // reset watchdog
              
                 RSTSRC   = 0x06;             // enable missing clock detector and 
                                              // VDD monitor as reset sourse
              #else /* CPU_C8051F310 */
1189   1      
1190   1         WDTCN    = 0x07;             // 95 msec (11.052 MHz) / 21msec (49 MHz)
1191   1         WDTCN    = 0xA5;             // start watchdog
1192   1      
1193   1      #if defined(CPU_C8051F120)
1194   1         SFRPAGE = LEGACY_PAGE;
1195   1         RSTSRC  = 0x04;              // enable missing clock detector
1196   1      #else
                 OSCICN |= 0x80;              // enable missing clock detector
                 RSTSRC  = 0x09;              // enable reset pin and watchdog reset
              #endif
1200   1      
1201   1      #endif /* not CPU_C8051F310 */
1202   1      #endif /* not CFG_EXT_WATCHDOG */
1203   1      #endif /* CFG_USE_WATCHDOG */
1204   1      }
1205          
1206          /*------------------------------------------------------------------*/
1207          
1208          void watchdog_disable(void)
1209          /********************************************************************\
1210          
1211            Routine: watchdog_disable
1212          
1213            Purpose: Disables watchdog
1214          
1215          \********************************************************************/
1216          {
1217   1      #ifdef CFG_USE_WATCHDOG
1218   1         watchdog_on = 0;
1219   1         watchdog_timer = 0;
1220   1         watchdog_timeout = 255;
1221   1      #endif
1222   1      
1223   1      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                 PCA0MD = 0x00;
              #else
1226   1         WDTCN  = 0xDE;
1227   1         WDTCN  = 0xAD;
1228   1      #endif
1229   1      }
1230          
1231          /*------------------------------------------------------------------*/
1232          
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 21  

1233          void watchdog_int(void) reentrant
1234          /********************************************************************\
1235          
1236            Routine: watchdog_int
1237          
1238            Purpose: Called by 100Hz interrupt routine to refresh watchdog
1239          
1240          \********************************************************************/
1241          {
1242   1      #ifdef CFG_USE_WATCHDOG
1243   1      
1244   1         /* timer expires after 10 sec of inactivity */
1245   1         watchdog_timer++;
1246   1         if (watchdog_on && watchdog_timer < watchdog_timeout*100) {
1247   2      
1248   2      #ifndef CFG_EXT_WATCHDOG // internal watchdog
1249   2      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                    PCA0CPH4 = 0x00;
              #else
1252   2            WDTCN = 0xA5;
1253   2      #endif
1254   2      #endif // !CFG_EXT_WATCHDOG
1255   2      
1256   2         }
1257   1      
1258   1      #ifdef CFG_EXT_WATCHDOG // reset external watchdog even if not on
                 if (watchdog_timer < watchdog_timeout*100) {
              #ifdef EXT_WATCHDOG_PIN_DAC1
                    unsigned char old_page;
                    old_page = SFRPAGE;
                    SFRPAGE = DAC1_PAGE;
                    DAC1CN = 0x80; // enable DAC1
                    SFRPAGE = LEGACY_PAGE;
                    REF0CN = 0x03; // enable voltage reference
                    SFRPAGE = DAC1_PAGE;
              
                    DAC1L = DAC1L > 0 ? 0 : 0xFF;
                    DAC1H = DAC1L;
                    SFRPAGE = old_page;
              #else
                    EXT_WATCHDOG = !EXT_WATCHDOG;
              #endif
                 }
              #endif // CFG_EXT_WATCHDOG
1277   1      
1278   1      #endif // CFG_USE_WATCHDOG
1279   1      }
1280          
1281          /*------------------------------------------------------------------*\
1282          
1283          
1284          /********************************************************************\
1285          
1286            Routine: delay_ms, delay_us
1287          
1288            Purpose: Delay functions for 11.0520 MHz quartz
1289          
1290          \********************************************************************/
1291          
1292          void delay_ms(unsigned int ms)
1293          {
1294   1         unsigned int i;
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 22  

1295   1      
1296   1         for (i = 0; i < ms; i++) {
1297   2            delay_us(1000);
1298   2            watchdog_refresh(1);
1299   2         }
1300   1      }
1301          
1302          void delay_us(unsigned int us)
1303          {
1304   1         unsigned char i, j;
1305   1         unsigned int remaining_us;
1306   1      
1307   1         if (j);
1308   1         if (us <= 250) {
1309   2            for (i = (unsigned char) us; i > 0; i--) {
1310   3      #if defined(CLK_25MHZ)
1311   3               _nop_();
1312   3               for (j=3 ; j>0 ; j--)
1313   3                  _nop_();
1314   3      #elif defined(CLK_98MHZ)
                       for (j=22 ; j>0 ; j--)
                          _nop_();
              #elif defined(CPU_C8051F310)
                       _nop_();
                       for (j=3 ; j>0 ; j--)
                          _nop_();
              #elif defined(CPU_C8051F320)
                       if (j);
                       _nop_();
                       _nop_();
              #else
                       _nop_();
              #endif
1328   3            }
1329   2         } else {
1330   2            remaining_us = us;
1331   2            while (remaining_us > 250) {
1332   3               delay_us(250);
1333   3               remaining_us -= 250;
1334   3            }
1335   2            if (us > 0)
1336   2               delay_us(remaining_us);
1337   2         }
1338   1      }
1339          
1340          /*------------------------------------------------------------------*/
1341          
1342          #ifdef CFG_HAVE_EEPROM
1343          
1344          unsigned char code EEPROM_AREA[N_EEPROM_PAGE*512] _at_ EEPROM_OFFSET;
1345          
1346          void eeprom_read(void * dst, unsigned char len, unsigned short *offset)
1347          /********************************************************************\
1348          
1349            Routine: eeprom_read
1350          
1351            Purpose: Read from internal EEPROM
1352          
1353            Input:
1354              unsigned char idata *dst    Destination in IDATA memory
1355              unsigned char len           Number of bytes to copy
1356              unsigend char *offset       Offset in EEPROM in bytes, gets
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 23  

1357                                          adjusted after read
1358          
1359          \********************************************************************/
1360          {
1361   1         unsigned char i;
1362   1         unsigned char code *p;
1363   1         unsigned char *d;
1364   1      
1365   1         watchdog_refresh(1);
1366   1      
1367   1         p = EEPROM_OFFSET + *offset;        // read from 128-byte EEPROM page
1368   1         d = dst;
1369   1      
1370   1         for (i = 0; i < len; i++)
1371   1            d[i] = p[i];
1372   1      
1373   1         *offset += len;
1374   1      }
1375          
1376          /*------------------------------------------------------------------*/
1377          
1378          void eeprom_write(void * src, unsigned char len, unsigned short *offset)
1379          /********************************************************************\
1380          
1381            Routine: eeprom_write
1382          
1383            Purpose: Read from internal EEPROM
1384          
1385            Input:
1386              unsigned char idata *src    Source in IDATA memory
1387              unsigned char len           Number of bytes to copy
1388              unsigend char offset        Offset in EEPROM in bytes, gets
1389                                          adjusted after write
1390          
1391          \********************************************************************/
1392          {
1393   1         unsigned char xdata * idata p;      // xdata pointer causes MOVX command
1394   1         unsigned char idata i, b;
1395   1         unsigned char * idata s;
1396   1      
1397   1         if (_flkey != 0xF1)
1398   1            return;
1399   1      
1400   1         watchdog_disable();
1401   1         DISABLE_INTERRUPTS;
1402   1      
1403   1      #ifdef CPU_C8051F120
1404   1         SFRPAGE = LEGACY_PAGE;
1405   1      #endif
1406   1      
1407   1      #if defined(CPU_C8051F000)
                 FLSCL = (FLSCL & 0xF0) | 0x08;  // set timer for 11.052 MHz clock
              #elif defined(CPU_C8051F020) || defined(CPU_C8051F120)
1410   1         FLSCL = FLSCL | 1;           // enable flash writes
1411   1      #endif
1412   1         PSCTL = 0x01;                // allow write
1413   1      
1414   1         p = EEPROM_OFFSET + *offset;
1415   1         s = src;
1416   1      
1417   1         for (i = 0; i < len; i++) {  // write data
1418   2            b = *s++;
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 24  

1419   2      
1420   2      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                    FLKEY = 0xA5;             // write flash key code
                    FLKEY = _flkey;
              #endif
1424   2      
1425   2            *p++ = b;
1426   2         }
1427   1      
1428   1         PSCTL = 0x00;                // don't allow write
1429   1         FLSCL = FLSCL & 0xF0;
1430   1      
1431   1         *offset += len;
1432   1      
1433   1         ENABLE_INTERRUPTS;
1434   1         watchdog_enable(0);
1435   1      }
1436          
1437          /*------------------------------------------------------------------*/
1438          
1439          void eeprom_erase(void)
1440          /********************************************************************\
1441          
1442            Routine: eeprom_erase
1443          
1444            Purpose: Erase parameter EEPROM page
1445          
1446          \********************************************************************/
1447          {
1448   1         unsigned char idata i;
1449   1         unsigned char xdata * idata p;
1450   1      
1451   1         if (_flkey != 0xF1)
1452   1            return;
1453   1      
1454   1         DISABLE_INTERRUPTS;
1455   1         watchdog_disable();
1456   1      
1457   1      #ifdef CPU_C8051F120
1458   1         SFRPAGE = LEGACY_PAGE;
1459   1      #endif
1460   1      
1461   1      #if defined(CPU_C8051F000)
                 FLSCL = (FLSCL & 0xF0) | 0x08;       // set timer for 11.052 MHz clock
              #elif defined(CPU_C8051F020) || defined(CPU_C8051F120)
1464   1         FLSCL = FLSCL | 1;                   // enable flash writes
1465   1      #endif
1466   1         PSCTL = 0x03;                        // allow write and erase
1467   1      
1468   1      #if defined(CPU_C8051F310) || defined(CPU_C8051F320)
                 p = EEPROM_OFFSET;
                 for (i=0 ; i<N_EEPROM_PAGE ; i++) {
                    FLKEY = 0xA5;                        // write flash key code
                    FLKEY = _flkey;
                    *p = 0;                              // erase page
                    watchdog_refresh(1);
                    p += 512;
                 }
              #else
1478   1         p = EEPROM_OFFSET;
1479   1         for (i=0 ; i<N_EEPROM_PAGE ; i++) {
1480   2            *p = 0; // erase page
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 25  

1481   2            watchdog_refresh(1);
1482   2            p += 512;
1483   2         }
1484   1      #endif
1485   1      
1486   1         PSCTL = 0x00;                        // don't allow write
1487   1         FLSCL = FLSCL & 0xF0;
1488   1      
1489   1         ENABLE_INTERRUPTS;
1490   1         watchdog_enable(0);
1491   1      }
1492          
1493          /*------------------------------------------------------------------*/
1494          
1495          void eeprom_flash(void)
1496          /********************************************************************\
1497          
1498            Routine: eeprom_flash
1499          
1500            Purpose: Write system and user parameters to EEPROM
1501          
1502          \********************************************************************/
1503          {
1504   1         unsigned char i, adr;
1505   1         unsigned short magic, offset;
1506   1      
1507   1         eeprom_erase();
1508   1      
1509   1         offset = 0;
1510   1      
1511   1         // system info (node address etc...)
1512   1         eeprom_write(&sys_info, sizeof(SYS_INFO), &offset);
1513   1      
1514   1         // magic
1515   1         magic = 0x1234;
1516   1         eeprom_write(&magic, 2, &offset);
1517   1      
1518   1         // user channel variables
1519   1         for (adr = 0 ; adr < _n_sub_addr ; adr++)
1520   1            for (i = 0; variables[i].width; i++)
1521   1               eeprom_write((char *)variables[i].ud + _var_size*adr,
1522   1                            variables[i].width, &offset);
1523   1      
1524   1         // magic
1525   1         magic = 0x1234;
1526   1         eeprom_write(&magic, 2, &offset);
1527   1      
1528   1         _flkey = 0;
1529   1      }
1530          
1531          /*------------------------------------------------------------------*/
1532          
1533          unsigned char eeprom_retrieve(unsigned char flag)
1534          /********************************************************************\
1535          
1536            Routine: eeprom_retrieve
1537          
1538            Purpose: Retrieve system parameters from EEPROM
1539                     If flag=1, also retrieve user variables from EEPROM
1540          
1541          \********************************************************************/
1542          {
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 26  

1543   1         unsigned char i, adr, status;
1544   1         unsigned short magic, offset;
1545   1      
1546   1         offset = 0;
1547   1         status = 0;
1548   1      
1549   1         // system info (node address etc...)
1550   1         eeprom_read(&sys_info, sizeof(SYS_INFO), &offset);
1551   1      
1552   1         // check for first magic
1553   1         eeprom_read(&magic, 2, &offset);
1554   1         if (magic == 0x1234)
1555   1            status |= (1 << 0);
1556   1      
1557   1         // user channel variables
1558   1         for (adr = 0 ; adr < _n_sub_addr ; adr++)
1559   1            for (i = 0; variables[i].width; i++) {
1560   2               if (flag)
1561   2                  eeprom_read((char *)variables[i].ud + _var_size*adr,
1562   2                              variables[i].width, &offset);
1563   2               else
1564   2                  offset += variables[i].width;
1565   2            }
1566   1      
1567   1         // check for second magic
1568   1         eeprom_read(&magic, 2, &offset);
1569   1         if (magic == 0x1234)
1570   1            status |= (1 << 1);
1571   1      
1572   1         return status;
1573   1      }
1574          
1575          #endif /* CFG_HAVE_EEPROM */
1576          
1577          /*---- EMIF routines -----------------------------------------------*/
1578          
1579          #ifdef CFG_HAVE_EMIF
              
              void emif_switch(unsigned char bk)
              {
                 unsigned char idata d;
              
                 d = (bk & 0x07);      // A16-A18
                 if (bk & 0x08)
                   d |= 0x20;          // /CS0=high, /CS1=low  (ext. inv.)
                 else
                   d |= 0x00;          // /CS0=low,  /CS1=high
              
                 d |= 0xC0;            // /RD=/WR=high
              
                 P4 = d;
              }
              
              /*------------------------------------------------------------------*/
              
              void emif_test(unsigned char n_banks)
              {
                 unsigned char idata i, error;
                 unsigned char xdata *p;
              
                 lcd_clear();
                 lcd_goto(2, 1);
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 27  

                 printf("Memory test...");
                 error = 0;
              
                 /* don't let clock interrupt update time in XDATA space */
                 watchdog_disable();
                 DISABLE_INTERRUPTS;
              
                 for (i=0 ; i<n_banks ; i++) {
                    emif_switch(i);
              
                    lcd_goto(i, 3);
                    putchar(218);
              
                    for (p=0x2000 ; p<0xFFFF ; p++)
                       *p = 0;
              
                    for (p=0x2000 ; p<0xFFFF ; p++)
                       if (*p != 0) {
                          error = 1;
                          break;
                       }
                    if (error)
                       break;
              
                    lcd_goto(i, 3);
                    putchar(217);
              
                    for (p=0x2000 ; p<0xFFFF ; p++)
                       *p = 0x55;
              
                    for (p=0x2000 ; p<0xFFFF ; p++)
                       if (*p != 0x55) {
                          error = 1;
                          break;
                       }
                    if (error)
                       break;
              
              
                    lcd_goto(i, 3);
                    putchar(216);
              
                    for (p=0x2000 ; p<0xFFFF ; p++)
                       *p = 0xAA;
              
                    for (p=0x2000 ; p<0xFFFF ; p++)
                       if (*p != 0xAA) {
                          error = 1;
                          break;
                       }
                    if (error)
                       break;
              
                    lcd_goto(i, 3);
                    putchar(215);
              
                    for (p=0x2000 ; p<0xFFFF ; p++)
                       *p = 0xFF;
              
                    for (p=0x2000 ; p<0xFFFF ; p++)
                       if (*p != 0xFF) {
                          error = 1;
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 28  

                          break;
                       }
                    if (error)
                       break;
              
                    lcd_goto(i, 3);
                    putchar(214);
                 }
              
                 ENABLE_INTERRUPTS;
                 watchdog_enable(0);
              
                 emif_switch(0);
                 if (error) {
                    lcd_goto(0, 2);
                    printf("Memory error bank %bd", i);
                    do {
                       watchdog_refresh(0);
                    } while (1);
                 }
              }
              
              /*------------------------------------------------------------------*/
              
              unsigned char emif_init()
              {
              unsigned char xdata *p;
              unsigned char idata d;
              
                 /* setup EMIF interface and probe external memory */
                 SFRPAGE = EMI0_PAGE;
                 //EMI0CF  = 0x3C; // active on P4-P7, non-multiplexed, external only
                 EMI0CF  = 0x38; // active on P4-P7, non-multiplexed, split mode
                 EMI0CN  = 0x00; // page zero
                 EMI0TC  = 0x04; // 2 SYSCLK cycles (=20ns) /WR and /RD signals
              
                 /* configure EMIF ports as push/pull */
                 SFRPAGE = CONFIG_PAGE;
                 P4MDOUT = 0xFF;
                 P5MDOUT = 0xFF;
                 P6MDOUT = 0xFF;
                 P7MDOUT = 0xFF;
              
                 /* "park" ports */
                 P4 = P5 = P6 = P7 = 0xFF;
              
                 /* test for external memory */
                 emif_switch(0);
                 p = 0x2000;
                 d = *p;
                 *p = 0x55;
                 if (*p != 0x55) {
                    *p = d; // restore previous data;
                    /* turn off EMIF */
                    SFRPAGE = EMI0_PAGE;
                    EMI0CF  = 0x00;
                    return 0;
                 }
                 *p = d; // restore previous data;
              
                 /* test for second SRAM chip */
                 emif_switch(8);
C51 COMPILER V9.01   MSCBUTIL                                                              11/15/2013 10:23:26 PAGE 29  

                 d = *p;
                 *p = 0xAA;
                 if (*p == 0xAA) { 
                    *p = d; // restore previous data;
                    emif_switch(0);
                    return 16;
                 }
                 *p = d; // restore previous data;
              
                 emif_switch(0);
              
                 return 8;
              }
              
              #endif // CFG_HAVE_EMIF


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2965    ----
   CONSTANT SIZE    =    276    ----
   XDATA SIZE       =   3097    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      48
   IDATA SIZE       =      3      18
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
