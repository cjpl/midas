C51 COMPILER V9.01   SCS_210_MAXIGAUGE                                                     11/18/2013 15:34:03 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SCS_210_MAXIGAUGE
OBJECT MODULE PLACED IN scs_210_maxigauge.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE scs_210_maxigauge.c OPTIMIZE(4,SPEED) BROWSE INCDIR(\midas\mscb\embedded\in
                    -clude) DEBUG OBJECTEXTEND TABS(3)

line level    source

   1          /********************************************************************\
   2          
   3            Name:         scs_210_maxigauge.c
   4            Created by:   Andreas Knecht
   5          
   6            Contents:     Application specific (user) part of
   7                          Midas Slow Control Bus protocol 
   8                          for SCS-210 RS232 node connected to a
   9                          Pfeiffer Maxigauge
  10          
  11            $Id$
  12          
  13          \********************************************************************/
  14          
  15          #include <stdio.h>
  16          #include <stdlib.h> // for atof()
  17          #include <string.h>
  18          
  19          #include "mscbemb.h"
  20          
  21          extern bit FREEZE_MODE;
  22          extern bit DEBUG_MODE;
  23          
  24          char code node_name[] = "maxigauge";
  25          
  26          /* declare number of sub-addresses to framework */
  27          unsigned char idata _n_sub_addr = 1;
  28          
  29          bit flush_flag;
  30          static unsigned long xdata last_read = 0;
  31          
  32          /*---- Define variable parameters returned to CMD_GET_INFO command ----*/
  33          
  34          /* data buffer (mirrored in EEPROM) */
  35          
  36          typedef struct {
  37             float p[6];
  38             char str1[32];
  39             char str2[32];
  40             unsigned char baud;
  41          } USER_DATA;
  42          
  43          USER_DATA xdata user_data;
  44          
  45          MSCB_INFO_VAR code vars[] = {
  46             1, UNIT_ASCII,  0, 0, MSCBF_DATALESS, "RS232",               0,
  47             32, UNIT_STRING,  0, 0, 0, "str1",          &user_data.str1,
  48             32, UNIT_STRING,  0, 0, 0, "str2",          &user_data.str2,
  49             4, UNIT_BAR, PRFX_MILLI, 0,    MSCBF_FLOAT, "P1",      &user_data.p[0],
  50             4, UNIT_BAR, PRFX_MILLI, 0,    MSCBF_FLOAT, "P2",      &user_data.p[1],
  51             4, UNIT_BAR, PRFX_MILLI, 0,    MSCBF_FLOAT, "P3",      &user_data.p[2],
  52             4, UNIT_BAR, PRFX_MILLI, 0,    MSCBF_FLOAT, "P4",      &user_data.p[3],
  53             4, UNIT_BAR, PRFX_MILLI, 0,    MSCBF_FLOAT, "P5",      &user_data.p[4],
  54             4, UNIT_BAR, PRFX_MILLI, 0,    MSCBF_FLOAT, "P6",      &user_data.p[5],
C51 COMPILER V9.01   SCS_210_MAXIGAUGE                                                     11/18/2013 15:34:03 PAGE 2   

  55             1, UNIT_BAUD,         0, 0,              0, "Baud",    &user_data.baud,
  56             0
  57          };
  58          
  59          MSCB_INFO_VAR *variables = vars;
  60          
  61          /********************************************************************\
  62           
  63            Application specific init and inout/output routines
  64          
  65          \********************************************************************/
  66          
  67          void user_write(unsigned char index) reentrant;
  68          void write_gain(void);
  69          
  70          /*---- User init function ------------------------------------------*/
  71          
  72          void user_init(unsigned char init)
  73          {
  74   1         /* initialize UART1 */
  75   1         if (init)
  76   1            user_data.baud = BD_9600;   // 9600 by default
  77   1      
  78   1         uart_init(1, user_data.baud);
  79   1      }
  80          
  81          /*---- User write function -----------------------------------------*/
  82          
  83          /* buffers in mscbmain.c */
  84          extern unsigned char xdata in_buf[256], out_buf[64];
  85          
  86          #pragma NOAREGS
  87          
  88          void user_write(unsigned char index) reentrant
  89          {
  90   1         unsigned char i, n;
  91   1      
  92   1         if (index == 0) {
  93   2            /* prevent reads for 1s */
  94   2            last_read = time();
  95   2      
  96   2            /* send characters */
  97   2            n = in_buf[1]-1;
  98   2            for (i = 0; i < n; i++)
  99   2               putchar(in_buf[3 + i]);
 100   2            flush_flag = 1;
 101   2         }
 102   1      
 103   1         if (index == 3)
 104   1            uart_init(1, user_data.baud);
 105   1      }
 106          
 107          
 108          /*---- User read function ------------------------------------------*/
 109          
 110          unsigned char user_read(unsigned char index)
 111          {
 112   1         char c, n;
 113   1      
 114   1         if (index == 0) {
 115   2      
 116   2            /* prevent pump reads for 1s */
C51 COMPILER V9.01   SCS_210_MAXIGAUGE                                                     11/18/2013 15:34:03 PAGE 3   

 117   2            last_read = time();
 118   2      
 119   2            for (n=0 ; n<32 ; n++) {
 120   3               c = getchar_nowait();
 121   3               if (c == -1)
 122   3                  break;
 123   3      
 124   3               /* put character directly in return buffer */
 125   3               out_buf[2 + n] = c;
 126   3            }
 127   2            return n;
 128   2         }
 129   1      
 130   1         return 0;
 131   1      }
 132          
 133          /*---- User function called vid CMD_USER command -------------------*/
 134          
 135          unsigned char user_func(unsigned char *data_in, unsigned char *data_out)
 136          {
 137   1         /* echo input data */
 138   1         data_out[0] = data_in[0];
 139   1         data_out[1] = data_in[1];
 140   1         return 2;
 141   1      }
 142          
 143          /*---- User loop function ------------------------------------------*/
 144          
 145          void user_loop(void)
 146          {
 147   1         unsigned char xdata i, r;
 148   1         float xdata p;
 149   1         char xdata str[32];
 150   1         int xdata status;
 151   1      
 152   1         const char *SensorStrings[6] = {"PR1\r\n", "PR2\r\n", "PR3\r\n", "PR4\r\n", "PR5\r\n", "PR6\r\n"};
 153   1      
 154   1      
 155   1         if (flush_flag) {
 156   2            flush_flag = 0;
 157   2            flush();
 158   2         }
 159   1      
 160   1         /* read parameters once each second */
 161   1         if (time() > last_read + 100) {
 162   2            last_read = time();
 163   2          
 164   2            for (i=0; i<6; i++){
 165   3               // Query sensor status and value
 166   3               //printf("PR%d\r\n", i+1);
 167   3               printf(SensorStrings[i]);
 168   3               flush();
 169   3      
 170   3               // Read reply device
 171   3               r = gets_wait(str, sizeof(str), 200);
 172   3               
 173   3               DISABLE_INTERRUPTS;
 174   3               strcpy(user_data.str1, str);
 175   3               ENABLE_INTERRUPTS;
 176   3               
 177   3               if (str[0] == 6) { // 6: Acknowledged query
 178   4               //if (1) {
C51 COMPILER V9.01   SCS_210_MAXIGAUGE                                                     11/18/2013 15:34:03 PAGE 4   

 179   4       
 180   4                  // Query sending of data
 181   4                  printf("%c", 5); // ENQ
 182   4                  flush();
 183   4                  
 184   4                  // Read sensor status and value
 185   4                  r = gets_wait(str, sizeof(str), 200);
 186   4      
 187   4                  DISABLE_INTERRUPTS;
 188   4                  strcpy(user_data.str2, str);
 189   4                  ENABLE_INTERRUPTS;
 190   4      
 191   4                  // Convert characters to values
 192   4                  status = atoi((char *)&str[0]);
 193   4                  p = atof(str+2);
 194   4      
 195   4                  if (status == 0) {
 196   5                     DISABLE_INTERRUPTS;
 197   5                     user_data.p[i] = p;
 198   5                     ENABLE_INTERRUPTS;
 199   5                  }
 200   4                  else {
 201   5                     DISABLE_INTERRUPTS;
 202   5                     user_data.p[i] = 0.0;
 203   5                     ENABLE_INTERRUPTS;
 204   5                  }
 205   4               }
 206   3            }
 207   2         }
 208   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    575    ----
   CONSTANT SIZE    =    243    ----
   XDATA SIZE       =     93      40
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3      26
   IDATA SIZE       =      1    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
