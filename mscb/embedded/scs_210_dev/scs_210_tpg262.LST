C51 COMPILER V9.01   SCS_210_TPG262                                                        11/13/2013 12:59:55 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SCS_210_TPG262
OBJECT MODULE PLACED IN scs_210_tpg262.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE scs_210_tpg262.c OPTIMIZE(4,SPEED) BROWSE INCDIR(..\include) DEBUG OBJECTEX
                    -TEND

line level    source

   1          /********************************************************************\
   2          
   3            Name:         scs_210.c
   4            Created by:   Stefan Ritt
   5          
   6          
   7            Contents:     Application specific (user) part of
   8                          Midas Slow Control Bus protocol 
   9                          for SCS-210 RS232 node connected to a
  10                          Pfeiffer Dual Gauge TPG262 vacuum sensor
  11          
  12            $Id$
  13          
  14          \********************************************************************/
  15          
  16          #include <stdio.h>
  17          #include <stdlib.h>             // for atof()
  18          #include "mscbemb.h"
  19          
  20          extern bit FREEZE_MODE;
  21          extern bit DEBUG_MODE;
  22          
  23          char code node_name[] = "TPG262";
  24          
  25          /* declare number of sub-addresses to framework */
  26          unsigned char idata _n_sub_addr = 1;
  27          
  28          bit flush_flag;
  29          static unsigned long last_read = 0;
  30          
  31          /*---- Define variable parameters returned to CMD_GET_INFO command ----*/
  32          
  33          /* data buffer (mirrored in EEPROM) */
  34          
  35          struct {
  36             float p1;
  37             float p2;
  38             unsigned char baud;
  39          } idata user_data;
  40          
  41          
  42          MSCB_INFO_VAR code vars[] = {
  43             1, UNIT_ASCII,  0, 0, MSCBF_DATALESS, "RS232",               0,
  44             4, UNIT_PASCAL, 0, 0,    MSCBF_FLOAT, "P1",      &user_data.p1,
  45             4, UNIT_PASCAL, 0, 0,    MSCBF_FLOAT, "P2",      &user_data.p2,
  46          
  47             1, UNIT_BAUD,   0, 0,              0, "Baud",  &user_data.baud,
  48             0
  49          };
  50          
  51          MSCB_INFO_VAR *variables = vars;
  52          
  53          /********************************************************************\
  54          
C51 COMPILER V9.01   SCS_210_TPG262                                                        11/13/2013 12:59:55 PAGE 2   

  55            Application specific init and inout/output routines
  56          
  57          \********************************************************************/
  58          
  59          void user_write(unsigned char index) reentrant;
  60          void write_gain(void);
  61          
  62          /*---- User init function ------------------------------------------*/
  63          
  64          void user_init(unsigned char init)
  65          {
  66   1         /* initialize UART1 */
  67   1         if (init)
  68   1            user_data.baud = BD_9600;   // 9600 by default
  69   1      
  70   1         uart_init(1, user_data.baud);
  71   1      }
  72          
  73          /*---- User write function -----------------------------------------*/
  74          
  75          /* buffers in mscbmain.c */
  76          extern unsigned char xdata in_buf[300], out_buf[300];
  77          
  78          #pragma NOAREGS
  79          
  80          void user_write(unsigned char index) reentrant
  81          {
  82   1         unsigned char i, n;
  83   1      
  84   1         if (index == 0) {
  85   2            /* prevent reads for 1s */
  86   2            last_read = time();
  87   2      
  88   2            /* send characters */
  89   2            n = in_buf[1]-1;
  90   2            for (i = 0; i < n; i++)
  91   2               putchar(in_buf[3 + i]);
  92   2            flush_flag = 1;
  93   2         }
  94   1      
  95   1         if (index == 3)
  96   1            uart_init(1, user_data.baud);
  97   1      }
  98          
  99          /*---- User read function ------------------------------------------*/
 100          
 101          unsigned char user_read(unsigned char index)
 102          {
 103   1         char c, n;
 104   1      
 105   1         if (index == 0) {
 106   2      
 107   2            /* prevent pump reads for 1s */
 108   2            last_read = time();
 109   2      
 110   2            for (n=0 ; n<32 ; n++) {
 111   3               c = getchar_nowait();
 112   3               if (c == -1)
 113   3                  break;
 114   3      
 115   3               /* put character directly in return buffer */
 116   3               out_buf[2 + n] = c;
C51 COMPILER V9.01   SCS_210_TPG262                                                        11/13/2013 12:59:55 PAGE 3   

 117   3            }
 118   2            return n;
 119   2         }
 120   1      
 121   1         return 0;
 122   1      }
 123          
 124          /*---- User function called vid CMD_USER command -------------------*/
 125          
 126          unsigned char user_func(unsigned char *data_in, unsigned char *data_out)
 127          {
 128   1         /* echo input data */
 129   1         data_out[0] = data_in[0];
 130   1         data_out[1] = data_in[1];
 131   1      
 132   1         return 2;
 133   1      }
 134          
 135          /*---- User loop function ------------------------------------------*/
 136          
 137          void user_loop(void)
 138          {
 139   1         char idata str[32];
 140   1         unsigned char i;
 141   1      
 142   1         if (flush_flag) {
 143   2            flush_flag = 0;
 144   2            flush();
 145   2         }
 146   1      
 147   1         /* read parameters once each second */
 148   1         if (time() > last_read + 100) {
 149   2            last_read = time();
 150   2      
 151   2            i = gets_wait(str, sizeof(str), 200);
 152   2      
 153   2            if (i == 0) {
 154   3               // start continuous mode, 1s update
 155   3               printf("COM,1\r\n");
 156   3               flush();
 157   3            } else if (i == 27) {
 158   3               user_data.p1 = atof(str + 2);
 159   3               user_data.p2 = atof(str + 16);
 160   3            }
 161   2         }
 162   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    352    ----
   CONSTANT SIZE    =     95    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      7       9
   IDATA SIZE       =     10      32
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
