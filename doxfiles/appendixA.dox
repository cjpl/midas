/*! @page AppendixA Data format

\htmlonly <img ALIGN="left" alt="previous.gif" src="previous.gif"> \endhtmlonly 
@ref Utilities - @ref Top - @ref AppendixB 
\htmlonly <img alt="next.gif" src="next.gif"> \endhtmlonly


Midas supports two differents data format so far. A possible new candidate would be the
NeXus format, but presently no implementation has been developed.
- @ref Midas_format
- @ref YBOS_format
- @ref History_format

<hr> @section Midas_format Midas format
Special formats are used in MIDAS for the event header, banks and when writing to disk
or tape.
This appendix explains these formats in detail.
Each event carries a 16-byte header. The header is generated by the front-end with the
bm_compose_event() routine and is used by consumers to distinguish between
different events.
The header is defined in the EVENT_HEADER structure in midas.h.
It has following structure:

 * <center> Event and bank headers with data block.
 *  \image html mEHBH.jpg
 *  \image latex mEHBH.eps "Event and bank headers with data block." width=12cm
 * </center> 

The event ID describes the type of event. Usually 1 is used for triggered events,
2 for scaler events, 3 for HV events etc.
The trigger mask can be used to describe the sub-type of an event.
A trigger event can have different trigger sources like "physics event",
"calibration event", "clock event". These trigger sources are usually read in
by the front-end in a pattern unit. Consumers can request events with a specific
triggering mask.
The serial number starts at one and is incremented by the front-end for each event.
The time stamp is written by the front-end before an event is read out.
It uses the time() function which returns the time in seconds since
1.1.1970 00:00:00 UTC.
The data size contains the number of bytes that follows the event header.
The data area of the event can contain information in any user format,
although only certain formats are supported when events are copied to the
ODB or written by the logger in ASCII format.
Event headers are always kept in the byte ordering of the local machine.
If events are sent over the network between computers with different byte
ordering, the event header is swapped automatically, but not the event contents.

- [Bank Format]
Events in MIDAS format contain "MIDAS banks". A bank is a substructure of an event
and can contain only one type of data, either a single value or an array of values.
Banks have a name of exactly four characters, which are treated, as a bank ID.
Banks in an event consist of a global bank header and an individual bank header
for each bank. Following picture shows a MIDAS event containing banks:
<br><br>
The "data size total" is the size in bytes of all bank headers and bank data.
Flags are currently not used. The bank header contains four characters as
identification, a bank type that is one of the TID_xxx values defined in
midas.h, and the data size in bytes.
If the byte ordering of the contents of a complete event has to be swapped,
the routine bk_swap() can be used.

- [Tape Format]
Events are written to disk files without any reformatting.
For tapes, a fixed block size is used. The block size TAPE_BUFFER_SIZE
is defined in midas.h and usually 32kB. Three special events are produced
by the system. A begin-of-run (BOR) and end-of-run (EOR)
event is produced which contains an ASCII dump of the ODB in its data area.
Their IDs is 0x8000 (BOR) and 0x8001 (EOR). A message event (ID 0x8002) is created
if Log messages is enabled in the logger channel setting.
The message is contained in the data area as an ASCII string.
The BOR event has the number MIDAS_MAGIC (0x494d or 'MI') as the trigger mask
and the current run number as the serial number.
A tape can therefore be identified as a MIDAS formatted tape.
The routine tape_copy() in the utility mtape.c is an example of how to read
a tape in MIDAS format.


<hr> @section YBOS_format YBOS format
As mentioned earlier the YBOS documentation is available at the following URL
address:
<a href="http://www-cdf.fnal.gov/offline/ybos/ybos.html">Ybos site</a>
Originally YBOS is a collection of FORTRAN functions which facilitate the
manipulation of group of data. It also describes a mode of encoding/storing
data in an organized way.
YBOS defines specific ways for:
- Gathering related data (bank structure).
- Gathering banks structure (logical record).
- Gathering/Writing/Reading logical record from/to storage device such as disk
or tape. (Physical record).

YBOS is organized on a 4-byte alignment structure.

The YBOS library function provides all the tools for manipulation of the above
mentioned elements in a independent Operating System like.
But the implementation of the YBOS part in Midas does not use any reference to
the YBOS library code. Instead only the strict necessary functions  have to be
re-written in C and incorporated into the Midas package.
This has been motivated by the fact that only a sub-set of function is
essential to the operation of:
- The front-end code: for the composition of the YBOS event (bank structure, logical record).
- The data logger: for writing data to storage device (physical record).

This Midas/YBOS implementation restricts the user to a subset of the YBOS
package only for the front-end part.
It doesn't prevent him/her to use the full YBOS library for stand alone
program accessing data file written by Midas. 

The YBOS implementation under Midas has the following restrictions:
- Single leveled bank structures only (no recursive bank allowed).
- Bank structure of the following type: ASCII, BINARY, WORD, DOUBLE WORD, IEEE FLOATING.
- No mixed data type bank structure allowed.

- Logical Record format (Event Format)
In the YBOS terminology a logical record refers to a collection of YBOS
bank while in the Midas front-end, it can be referred to as an event.
The logical record consists of a logical record length of a 32bit-word
size followed by a single or collection of YBOS bank.
The logical record length counts the number of double word (32bit word)
composing the record without counting itself.

YBOS uses "double word" unit for all length references.

- [Bank Format]
The YBOS bank is composed of a bank header 5 double long words followed by
the data section which has to end on a 4 bytes boundary.

 * <center> Ybos Event and bank headers with data block.
 *  \image html yEHBH.jpg
 *  \image latex yEHBH.eps "Ybos Event and bank headers with data block." width=12cm
 * </center> 

The bank length parameter corresponds to the size of the data section in double
word count + 1.
The supported bank type are defined in the ybos.h file see
@ref YBOS_Bank_Types. 

- [Physical Record (Tape/Disk Format)]
  The YBOS physical record structure is based on a fixed block size
  (8190 double words) composed of a physical record header followed by data
  from logical records.

 * <center> Ybos Physical record structure with data block.
 *  \image html yPH.jpg
 *  \image latex yPH.eps "Ybos Physical record structure with data block.." width=12cm
 * </center> 

The Offset is computed with the following rules:
- If the logical record fits completely in the space of the physical record,
  the offset value in the physical record header will be 4.
- If the block contains first the left over fragment of the previous
  event started in the previous block, the offset will be equal to the length
  of the physical record header + the left over fragment size.
- If the logical record extent beyond a full block, the offset will be set to -1.
- The mark of the end of file is defined with a logical record length set to -1.

<hr> @section History_format History format

MIDAS history data are written to MIDAS .hst files. For a complete working
example of reading these files, look at mhdump.cxx.

This is the internal format of MIDAS .hst files (reverse engineered by K.Olchanski).

History file consists of definition records and data records. Definition records for each history event always preceed data records for this event. Other than that, definition and data records are present in the file in no particular order. If data definition changes at some point, the new definition record is written to the file and new data records follow using the new format.

The data is written in native-endian format and big-endian history files (i.e. written on PowerPC-based computer) would not read on little-endian computers (i.e. Intel/AMD CPUs).

When decoding history data records, be aware that the data is written on the format returned by db_get_data(), and follow certain alignement rules. Misaligned data may contain empty padding bytes.

\code
definition record:
   struct HIST_RECORD:
      uint32_t record_type = 0x46445348 (RT_DEF)
      uint32_t event_id    = history event id
      uint32_t time        = unix time
      uint32_t def_offset  = 0
      uint32_t data_size   = size in bytes of following data = ntags*sizeof(TAG)
   event name:
      char name[NAME_LENGTH] = name of this event (fixed size, 32 bytes)
   struct TAG [0]
      char name[NAME_LENGTH] = tag name (fixed size, 32 bytes)
      uint32_t type          = type of the data (TID_DOUBLE, etc)
      uint32_t n_data        = 1 for single variables, number of array elements for arrays
   struct TAG [1]
      ...
   struct TAG [ntags-1]
      ...
\endcode

\code
data record:
   struct HIST_RECORD: (same as above)
      uint32_t record_type = 0x41445348 (RT_DATA)
      uint32_t event_id    = history event id
      uint32_t time        = unix time
      uint32_t def_offset  = ???
      uint32_t data_size   = size in bytes of following data
   event data
      char[data_size]      = history data for this event (see mhdump.cxx and examples below on decoding this data
\endcode

To decode the "event data" blob in a data record, one should parse the data definition for this event and remember the contents of all tag definitions. One way to parse the data is by computing the "offset" for each tag by adding up the tag size for each tag. For each tag, the corresponding data size is the product of n_data and the size of the MIDAS type, given in this table (extracted from midas.c):

\code
/* data type sizes */
int tid_size[] = {
   0,                           /* tid == 0 not defined                               */
   1,                           /* TID_BYTE      unsigned byte         0       255    */
   1,                           /* TID_SBYTE     signed byte         -128      127    */
   1,                           /* TID_CHAR      single character      0       255    */
   2,                           /* TID_WORD      two bytes             0      65535   */
   2,                           /* TID_SHORT     signed word        -32768    32767   */
   4,                           /* TID_DWORD     four bytes            0      2^32-1  */
   4,                           /* TID_INT       signed dword        -2^31    2^31-1  */
   4,                           /* TID_BOOL      four bytes bool       0        1     */
   4,                           /* TID_FLOAT     4 Byte float format                  */
   8,                           /* TID_DOUBLE    8 Byte float format                  */
   1,                           /* TID_BITFIELD  8 Bits Bitfield    00000000 11111111 */
   0,                           /* TID_STRING    zero terminated string               */
   0,                           /* TID_ARRAY     variable length array of unkown type */
   0,                           /* TID_STRUCT    C structure                          */
   0,                           /* TID_KEY       key in online database               */
   0                            /* TID_LINK      link in online database              */
};
\endcode

Example code for computing tag offsets:
\code
int offset = 0;
for (int itag=0; itag&lt;ntags; itag++) {
   int size = tags[itag].n_data * tid_size[tags[itag].type];
   type_for_tag[itag] = tags[itag].type;
   offset_for_tag[itag] = offset;
   offset += size;
}
\endcode

Example code for decoding the event data blob:
\code
char *buf = new char[data_size];
fread(buf, 1, data_size, f); // read data blob from file

int itag = ...; // the tag we want to look at
int j    = ...; // array index inside the tag

int offset = offset_for_tag[itag];
void* ptr = (void*)(buf+offset);

switch (type_for_tag[itag]) {
   default:
      printf("unknownType%d ",type_for_tag[itag]);
      break;
   case 6: /* DWORD */
      printf("%u ",((uint32_t*)ptr)[j]);
      break;
}
\endcode

\htmlonly <img ALIGN="left" alt="previous.gif" src="previous.gif"> \endhtmlonly 
@ref Utilities - @ref Top - @ref AppendixB 
\htmlonly <img alt="next.gif" src="next.gif"> \endhtmlonly
*/
